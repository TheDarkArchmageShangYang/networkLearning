# 前缀和

对于数组nums,定义其前缀和为:

sums[0] = 0
sums[1] = nums[0]
sums[2] = nums[0] + nums[1]
sums[i] = nums[0] + nums[1] + ⋯ + nums[i−1]
sums[i+1] = nums[0] + nums[1] + ⋯ + nums[i−1] + nums[i]
sums[n] = nums[0] + nums[1] + ⋯ + nums[n−1]

因此, sums[i+1] = sums[i] + nums[i].

通过前缀和,我们可以将连续子数组的元素和转换为两个前缀和的差.

即nums[i] + nums[i+1] + ⋯ + nums[j] = sums[j+1] - sums[i]



- 为什么要定义sums[0] = 0?

  nums[i] + nums[i+1] + ⋯ + nums[j] = (nums[0] + nums[1] + ⋯ + nums[j]) - 									 (nums[0] + nums[1] + ⋯ + nums[i-1])

  ​								   = sums[j+1] - sums[i]

  当 i = 0 时, (nums[1] + nums[2] + ⋯ + nums[i-1])为0

  为了将该情况也能表示为两个前缀和之差,定义了 sums[0] = 0.否则需要对 i = 0 额外讨论

- 为什么用sums[j+1]表示前j个数的前缀和,不能用sums[j]吗?

  nums[i] + nums[i+1] + ⋯ + nums[j] = (nums[0] + nums[1] + ⋯ + nums[j]) - 									 (nums[0] + nums[1] + ⋯ + nums[i-1])

  ​								   = sums[j] - sums[i-1]

  在 i = 0 时数组越界

- 常用于动态规划等需要对同一个函数反复调用的情况,避免每次调用时都需要遍历数组

## 例题

303.[区域和检索 - 数组不可变](https://leetcode.cn/problems/range-sum-query-immutable/)

给定一个整数数组  `nums`，处理以下类型的多个查询:

1. 计算索引 `left` 和 `right` （包含 `left` 和 `right`）之间的 `nums` 元素的 **和** ，其中 `left <= right`

实现 `NumArray` 类：

- `NumArray(int[] nums)` 使用数组 `nums` 初始化对象
- `int sumRange(int i, int j)` 返回数组 `nums` 中索引 `left` 和 `right` 之间的元素的 **总和** ，包含 `left` 和 `right` 两点（也就是 `nums[left] + nums[left + 1] + ... + nums[right]` )

 

**示例 1：**

```
输入：
["NumArray", "sumRange", "sumRange", "sumRange"]
[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]
输出：
[null, 1, -1, -3]

解释：
NumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);
numArray.sumRange(0, 2); // return 1 ((-2) + 0 + 3)
numArray.sumRange(2, 5); // return -1 (3 + (-5) + 2 + (-1)) 
numArray.sumRange(0, 5); // return -3 ((-2) + 0 + 3 + (-5) + 2 + (-1))
```

 

**提示：**

- `1 <= nums.length <= 104`
- `-105 <= nums[i] <= 105`
- `0 <= i <= j < nums.length`
- 最多调用 `104` 次 `sumRange` 方法



==**代码**==

```c++
class NumArray {
public:
    vector<int> sums;

    NumArray(vector<int>& nums) {
        int n = nums.size();
        sums.resize(n + 1);
        for (int i = 0; i < n; i++) {
            sums[i + 1] = sums[i] + nums[i];
        }    
    }
    
    int sumRange(int left, int right) {
        return sums[right + 1] - sums[left];
    }
};

/**
 * Your NumArray object will be instantiated and called as such:
 * NumArray* obj = new NumArray(nums);
 * int param_1 = obj->sumRange(left,right);
 */
```

