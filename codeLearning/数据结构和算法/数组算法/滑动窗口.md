# 滑动窗口

## 1.基本代码框架

使用左右指针

1.初始化 left = right = 0

2.不断增加right使窗口扩大,直到满足某个条件

3.不断增加left使窗口缩小,直到不再满足该条件

4.重复2/3,直到遍历完整个数组

### 定长滑动窗口模板

right指向下一个要加入窗口的值,即窗口为[left, right)

注意第一种写法虽然更美观易懂,但是在k = 0时会有bug

第二种写法与不定长模板基本一致,只是将第二个while改成if

```c++
void slidingWindow(string s, int k) {
    if (k == 0) {...}
    int n = s.length();
    int left = 0, right = 0;
    int window = ..., ans = ...;
    while (right < n) {
        // right进入窗口,更新统计值
        window.add(s[right]);
        right++;
        if (right < k) continue;
        // 更新答案,通常为最大值/最小值
        ans = ...;
        // left离开窗口,更新统计值
        window.remove(s[left]);
        left++;
    }
    return ans;
}

void slidingWindow(string s, int k) {
    int n = s.length();
    int left = 0, right = 0;
    int window = ..., ans = ...;
    while (right < n) {
        // right进入窗口,更新统计值
        window.add(s[right]);
        right++;
        if (right - left == k) {
            // 更新答案,通常为最大值/最小值
            ans = ...;
            // left离开窗口,更新统计值
            window.remove(s[left]);
            left++;
        }
    }
    return ans;
}
```



### 不定长滑动窗口模板

```c++
void slidingWindow(string s) {
    int window = ...

    int left = 0, right = 0;
    while (right < s.size()) {
        window.add(s[right]);
        ...
        right++;

        while (window needs shrink) {
            window.remove(s[left]);
            ...
            left++;
        }
    }
    return;
}
```

## 2.定长滑动窗口

### 题单

基础

- 1456.[定长子串中元音的最大数目](https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/description/)(1263)

- 643.[子数组最大平均数I](https://leetcode.cn/problems/maximum-average-subarray-i/description/)

- 1343.[大小为k且平均值大于等于阈值的子数组数目](https://leetcode.cn/problems/number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold/description/)(1317)
- 2090.[半径为k的子数组平均值](https://leetcode.cn/problems/k-radius-subarray-averages/description/)(1358)
- 2379.[得到K个黑块的最少涂色次数](https://leetcode.cn/problems/minimum-recolors-to-get-k-consecutive-black-blocks/description/)(1360)
- 1052.[爱生气的书店老板](https://leetcode.cn/problems/grumpy-bookstore-owner/description/)(1418)
- 1461.[检查一个字符串是否包含所有长度为K的二进制子串](https://leetcode.cn/problems/check-if-a-string-contains-all-binary-codes-of-size-k/description/)(1504)
- 2841.[几乎唯一子数组的最大和](https://leetcode.cn/problems/maximum-sum-of-almost-unique-subarray/description/)(1546)
- 2461.[长度为K子数组的最大和](https://leetcode.cn/problems/maximum-sum-of-distinct-subarrays-with-length-k/description/)(1553)
- 1423.[可获得的最大点数](https://leetcode.cn/problems/maximum-points-you-can-obtain-from-cards/description)(1574)
- 1652.[拆炸弹](https://leetcode.cn/problems/defuse-the-bomb/description/)
- 1297.[子串的最大出现次数](https://leetcode.cn/problems/maximum-number-of-occurrences-of-a-substring/description/)(1748)
- 2653.[滑动子数组的美丽值](https://leetcode.cn/problems/sliding-subarray-beauty/description/)(178



1456,643,1343,2379较为类似,为基础题,直接套用模板即可.

2090,1652需要对滑动窗口的窗口大小和边界进行讨论

1052,1423需要思考哪一部分应该用滑动窗口

1461,2841,2461,1297融入哈希表



### 1456.[定长子串中元音的最大数目](https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/description/)(1263)

给你字符串 `s` 和整数 `k` 。

请返回字符串 `s` 中长度为 `k` 的单个子字符串中可能包含的最大元音字母数。

英文中的 **元音字母** 为（`a`, `e`, `i`, `o`, `u`）。

 

**示例 1：**

```
输入：s = "abciiidef", k = 3
输出：3
解释：子字符串 "iii" 包含 3 个元音字母。
```

**示例 2：**

```
输入：s = "aeiou", k = 2
输出：2
解释：任意长度为 2 的子字符串都包含 2 个元音字母。
```

**示例 3：**

```
输入：s = "leetcode", k = 3
输出：2
解释："lee"、"eet" 和 "ode" 都包含 2 个元音字母。
```

**示例 4：**

```
输入：s = "rhythms", k = 4
输出：0
解释：字符串 s 中不含任何元音字母。
```

**示例 5：**

```
输入：s = "tryhard", k = 4
输出：1
```

 

**提示：**

- `1 <= s.length <= 10^5`
- `s` 由小写英文字母组成
- `1 <= k <= s.length`



==*代码*==

```c++
class Solution {
public:
    int maxVowels(string s, int k) {
        int n = s.length();
        int left = 0, right = 0;
        int num = 0, maxNum = 0;
        while (right < n) {
            if (s[right] == 'a' || s[right] == 'e' || s[right] == 'i' || s[right] == 'o' || s[right] == 'u') {
                num++;
            }
            right++;
            if (right < k) continue;
            maxNum = max(maxNum, num);
            if (s[left] == 'a' || s[left] == 'e' || s[left] == 'i' || s[left] == 'o' || s[left] == 'u') {
                num--;
            }
            left++;
        }
        return maxNum;
    }
};
```



### 2090.[半径为k的子数组平均值](https://leetcode.cn/problems/k-radius-subarray-averages/description/)(1358)

给你一个下标从 **0** 开始的数组 `nums` ，数组中有 `n` 个整数，另给你一个整数 `k` 。

**半径为 k 的子数组平均值** 是指：`nums` 中一个以下标 `i` 为 **中心** 且 **半径** 为 `k` 的子数组中所有元素的平均值，即下标在 `i - k` 和 `i + k` 范围（**含** `i - k` 和 `i + k`）内所有元素的平均值。如果在下标 `i` 前或后不足 `k` 个元素，那么 **半径为 k 的子数组平均值** 是 `-1` 。

构建并返回一个长度为 `n` 的数组 `avgs` ，其中 `avgs[i]` 是以下标 `i` 为中心的子数组的 **半径为 k 的子数组平均值** 。

`x` 个元素的 **平均值** 是 `x` 个元素相加之和除以 `x` ，此时使用截断式 **整数除法** ，即需要去掉结果的小数部分。

- 例如，四个元素 `2`、`3`、`1` 和 `5` 的平均值是 `(2 + 3 + 1 + 5) / 4 = 11 / 4 = 2.75`，截断后得到 `2` 。

 

**示例 1：**

![img](https://fzchen-picgo.oss-cn-shanghai.aliyuncs.com/Github/learning/20241207051734884.png)

```
输入：nums = [7,4,3,9,1,8,5,2,6], k = 3
输出：[-1,-1,-1,5,4,4,-1,-1,-1]
解释：
- avg[0]、avg[1] 和 avg[2] 是 -1 ，因为在这几个下标前的元素数量都不足 k 个。
- 中心为下标 3 且半径为 3 的子数组的元素总和是：7 + 4 + 3 + 9 + 1 + 8 + 5 = 37 。
  使用截断式 整数除法，avg[3] = 37 / 7 = 5 。
- 中心为下标 4 的子数组，avg[4] = (4 + 3 + 9 + 1 + 8 + 5 + 2) / 7 = 4 。
- 中心为下标 5 的子数组，avg[5] = (3 + 9 + 1 + 8 + 5 + 2 + 6) / 7 = 4 。
- avg[6]、avg[7] 和 avg[8] 是 -1 ，因为在这几个下标后的元素数量都不足 k 个。
```

**示例 2：**

```
输入：nums = [100000], k = 0
输出：[100000]
解释：
- 中心为下标 0 且半径 0 的子数组的元素总和是：100000 。
  avg[0] = 100000 / 1 = 100000 。
```

**示例 3：**

```
输入：nums = [8], k = 100000
输出：[-1]
解释：
- avg[0] 是 -1 ，因为在下标 0 前后的元素数量均不足 k 。
```

 

**提示：**

- `n == nums.length`
- `1 <= n <= 105`
- `0 <= nums[i], k <= 105`



==*代码*==

```c++
class Solution {
public:
    vector<int> getAverages(vector<int>& nums, int k) {
        int n = nums.size();
        int left = 0, right = 0;
        long long sum = 0;
        vector<int> ans(n, -1);
        while (right < n) {
            sum += nums[right];
            right++;
            if (right < 2 * k + 1) continue;
            ans[right - k - 1] = sum / (2 * k + 1);
            sum -= nums[left];
            left++;
        }
        return ans;
    }
};
```



### 1052.[爱生气的书店老板](https://leetcode.cn/problems/grumpy-bookstore-owner/description/)(1418)

有一个书店老板，他的书店开了 `n` 分钟。每分钟都有一些顾客进入这家商店。给定一个长度为 `n` 的整数数组 `customers` ，其中 `customers[i]` 是在第 `i` 分钟开始时进入商店的顾客数量，所有这些顾客在第 `i` 分钟结束后离开。

在某些分钟内，书店老板会生气。 如果书店老板在第 `i` 分钟生气，那么 `grumpy[i] = 1`，否则 `grumpy[i] = 0`。

当书店老板生气时，那一分钟的顾客就会不满意，若老板不生气则顾客是满意的。

书店老板知道一个秘密技巧，能抑制自己的情绪，可以让自己连续 `minutes` 分钟不生气，但却只能使用一次。

请你返回 *这一天营业下来，最多有多少客户能够感到满意* 。


**示例 1：**

```
输入：customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], minutes = 3
输出：16
解释：书店老板在最后 3 分钟保持冷静。
感到满意的最大客户数量 = 1 + 1 + 1 + 1 + 7 + 5 = 16.
```

**示例 2：**

```
输入：customers = [1], grumpy = [0], minutes = 1
输出：1
```

 

**提示：**

- `n == customers.length == grumpy.length`
- `1 <= minutes <= n <= 2 * 104`
- `0 <= customers[i] <= 1000`
- `grumpy[i] == 0 or 1`



==*代码*==

```c++
class Solution {
public:
    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {
        int n = customers.size();
        int left = 0, right = 0;
        int satisfiedCustomers = 0;
        int dissatisfiedCustomersInMinutes = 0, maxDissatisfiedCustomersInMinutes = 0;
        // 先统计出所有满意的用户,然后使用滑动窗口计算生气时minutes内最多不满意用户
        while (right < n) {
            satisfiedCustomers += grumpy[right] == 0 ? customers[right] : 0;
            dissatisfiedCustomersInMinutes += grumpy[right] == 1 ? customers[right] : 0;
            right++;
            if (right < minutes) continue;
            maxDissatisfiedCustomersInMinutes = max(maxDissatisfiedCustomersInMinutes, dissatisfiedCustomersInMinutes);
            dissatisfiedCustomersInMinutes -= grumpy[left] == 1 ? customers[left] : 0;;
            left++;
        }
        return satisfiedCustomers + maxDissatisfiedCustomersInMinutes;
    }
};
```



### 1461.[检查一个字符串是否包含所有长度为K的二进制子串](https://leetcode.cn/problems/check-if-a-string-contains-all-binary-codes-of-size-k/description/)(1504)

给你一个二进制字符串 `s` 和一个整数 `k` 。如果所有长度为 `k` 的二进制字符串都是 `s` 的子串，请返回 `true` ，否则请返回 `false` 。

 

**示例 1：**

```
输入：s = "00110110", k = 2
输出：true
解释：长度为 2 的二进制串包括 "00"，"01"，"10" 和 "11"。它们分别是 s 中下标为 0，1，3，2 开始的长度为 2 的子串。
```

**示例 2：**

```
输入：s = "0110", k = 1
输出：true
解释：长度为 1 的二进制串包括 "0" 和 "1"，显然它们都是 s 的子串。
```

**示例 3：**

```
输入：s = "0110", k = 2
输出：false
解释：长度为 2 的二进制串 "00" 没有出现在 s 中。
```

 

**提示：**

- `1 <= s.length <= 5 * 105`
- `s[i]` 不是`'0'` 就是 `'1'`
- `1 <= k <= 20`



==*代码*==

```c++
class Solution {
public:
    bool hasAllCodes(string s, int k) {
        unordered_set<string> hash_set;
        int n = s.length();
        int left = 0, right = 0;
        for (int i = 0; i <= n - k; i++) {
                hash_set.insert(s.substr(i, k));
        }
        return hash_set.size() == (1 << k);
    }
};
```



### 2841.[几乎唯一子数组的最大和](https://leetcode.cn/problems/maximum-sum-of-almost-unique-subarray/description/)(1546)

给你一个二进制字符串 `s` 和一个整数 `k` 。如果所有长度为 `k` 的二进制字符串都是 `s` 的子串，请返回 `true` ，否则请返回 `false` 。

 

**示例 1：**

```
输入：s = "00110110", k = 2
输出：true
解释：长度为 2 的二进制串包括 "00"，"01"，"10" 和 "11"。它们分别是 s 中下标为 0，1，3，2 开始的长度为 2 的子串。
```

**示例 2：**

```
输入：s = "0110", k = 1
输出：true
解释：长度为 1 的二进制串包括 "0" 和 "1"，显然它们都是 s 的子串。
```

**示例 3：**

```
输入：s = "0110", k = 2
输出：false
解释：长度为 2 的二进制串 "00" 没有出现在 s 中。
```

 

**提示：**

- `1 <= s.length <= 5 * 105`
- `s[i]` 不是`'0'` 就是 `'1'`
- `1 <= k <= 20`



==*代码*==

之所以要用map,而不是set,因为可能有多个连续数字如{1,1,1,3},可能会误判

注意hash_map创建num为key的键值对后,即使hash_map[num] = 0,仍会被size()函数计算在内,所以为0时需要erase()

```c++
class Solution {
public:
    long long maxSum(vector<int>& nums, int m, int k) {
        int n = nums.size();
        int left = 0, right = 0;
        unordered_map<int, int> hash_map;
        long long ans = 0, sum = 0;
        while (right < n) {
            hash_map[nums[right]]++;
            sum += nums[right];
            right++;
            if (right < k) continue;
            if (hash_map.size() >= m) {
                ans = max(ans, sum);
            }
            hash_map[nums[left]]--;
            if (hash_map[nums[left]] == 0) {
                hash_map.erase(nums[left]);
            }
            sum -= nums[left];
            left++;
        }
        return ans;
    }
};
```



### 1652.[拆炸弹](https://leetcode.cn/problems/defuse-the-bomb/description/)

你有一个炸弹需要拆除，时间紧迫！你的情报员会给你一个长度为 `n` 的 **循环** 数组 `code` 以及一个密钥 `k` 。

为了获得正确的密码，你需要替换掉每一个数字。所有数字会 **同时** 被替换。

- 如果 `k > 0` ，将第 `i` 个数字用 **接下来** `k` 个数字之和替换。
- 如果 `k < 0` ，将第 `i` 个数字用 **之前** `k` 个数字之和替换。
- 如果 `k == 0` ，将第 `i` 个数字用 `0` 替换。

由于 `code` 是循环的， `code[n-1]` 下一个元素是 `code[0]` ，且 `code[0]` 前一个元素是 `code[n-1]` 。

给你 **循环** 数组 `code` 和整数密钥 `k` ，请你返回解密后的结果来拆除炸弹！

 

**示例 1：**

```
输入：code = [5,7,1,4], k = 3
输出：[12,10,16,13]
解释：每个数字都被接下来 3 个数字之和替换。解密后的密码为 [7+1+4, 1+4+5, 4+5+7, 5+7+1]。注意到数组是循环连接的。
```

**示例 2：**

```
输入：code = [1,2,3,4], k = 0
输出：[0,0,0,0]
解释：当 k 为 0 时，所有数字都被 0 替换。
```

**示例 3：**

```
输入：code = [2,4,9,3], k = -2
输出：[12,5,6,13]
解释：解密后的密码为 [3+9, 2+3, 4+2, 9+4] 。注意到数组是循环连接的。如果 k 是负数，那么和为 之前 的数字。
```

 

**提示：**

- `n == code.length`
- `1 <= n <= 100`
- `1 <= code[i] <= 100`
- `-(n - 1) <= k <= n - 1`



==*代码*==

```c++
class Solution {
public:
    vector<int> decrypt(vector<int>& code, int k) {
        int n = code.size();
        vector<int> ans(n);
        if (k == 0) {
            return ans;
        }
        int cur = 0;
        int left = k > 0 ? 1 : n + k;
        int right = k > 0 ? 1 + k : n;
        int sum = 0;
        for (int i = left; i < right; i++) {
            sum += code[i];
        }
        while (cur < n) {
            ans[cur] = sum;
            cur++;
            sum += code[right % n] - code[left % n];
            left++;
            right++;
        }
        return ans;
    }
};
```



### 1297.[子串的最大出现次数](https://leetcode.cn/problems/maximum-number-of-occurrences-of-a-substring/description/)(1748)

给你一个字符串 `s` ，请你返回满足以下条件且出现次数最大的 **任意** 子串的出现次数：

- 子串中不同字母的数目必须小于等于 `maxLetters` 。
- 子串的长度必须大于等于 `minSize` 且小于等于 `maxSize` 。

 

**示例 1：**

```
输入：s = "aababcaab", maxLetters = 2, minSize = 3, maxSize = 4
输出：2
解释：子串 "aab" 在原字符串中出现了 2 次。
它满足所有的要求：2 个不同的字母，长度为 3 （在 minSize 和 maxSize 范围内）。
```

**示例 2：**

```
输入：s = "aaaa", maxLetters = 1, minSize = 3, maxSize = 3
输出：2
解释：子串 "aaa" 在原字符串中出现了 2 次，且它们有重叠部分。
```

**示例 3：**

```
输入：s = "aabcabcab", maxLetters = 2, minSize = 2, maxSize = 3
输出：3
```

**示例 4：**

```
输入：s = "abcde", maxLetters = 2, minSize = 3, maxSize = 3
输出：0
```

 

**提示：**

- `1 <= s.length <= 10^5`
- `1 <= maxLetters <= 26`
- `1 <= minSize <= maxSize <= min(26, s.length)`
- `s` 只包含小写英文字母。



==*代码*==

```c++
class Solution {
public:
    int maxFreq(string s, int maxLetters, int minSize, int maxSize) {
        int n = s.length();
        int left = 0, right = 0;
        unordered_map<char, int> hash_map;
        unordered_map<string, int> hash_map_ans;
        while (right < n) {
            hash_map[s[right]]++;
            right++;
            if (right < minSize) continue;
            if (hash_map.size() <= maxLetters) {
                hash_map_ans[s.substr(left, right - left)]++;
            }
            hash_map[s[left]]--;
            if (hash_map[s[left]] == 0) {
                hash_map.erase(s[left]);
            }
            left++;
        }
        int ans = 0;
        for (auto it : hash_map_ans) {
            ans = max(ans, it.second);
        }
        return ans;
    }
};
```



## 3.不定长滑动窗口

### 209.[长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/description/)

给定一个含有 `n` 个正整数的数组和一个正整数 `target` **。**

找出该数组中满足其总和大于等于 `target` 的长度最小的 

**子数组**

`[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度**。**如果不存在符合条件的子数组，返回 `0` 。



 

**示例 1：**

```
输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
```

**示例 2：**

```
输入：target = 4, nums = [1,4,4]
输出：1
```

**示例 3：**

```
输入：target = 11, nums = [1,1,1,1,1,1,1,1]
输出：0
```

 

**提示：**

- `1 <= target <= 109`
- `1 <= nums.length <= 105`
- `1 <= nums[i] <= 104`

 

**进阶：**

- 如果你已经实现 `O(n)` 时间复杂度的解法, 请尝试设计一个 `O(n log(n))` 时间复杂度的解法。



==*代码*==

```c++
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int n = nums.size();
        int left = 0, right = 0;
        int sum = 0, len = INT_MAX;
        while (right < n) {
            sum += nums[right];
            right++;

            while (sum >= target) {
                if (right - left < len) {
                    len = right - left;
                }
                sum -= nums[left];
                left++;
            }
        }
        return len == INT_MAX ? 0 : len;
    }
};
```





### 76.[最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/description/)

给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `""` 。

 

**注意：**

- 对于 `t` 中重复字符，我们寻找的子字符串中该字符数量必须不少于 `t` 中该字符数量。
- 如果 `s` 中存在这样的子串，我们保证它是唯一的答案。

 

**示例 1：**

```
输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
解释：最小覆盖子串 "BANC" 包含来自字符串 t 的 'A'、'B' 和 'C'。
```

**示例 2：**

```
输入：s = "a", t = "a"
输出："a"
解释：整个字符串 s 是最小覆盖子串。
```

**示例 3:**

```
输入: s = "a", t = "aa"
输出: ""
解释: t 中两个字符 'a' 均应包含在 s 的子串中，
因此没有符合条件的子字符串，返回空字符串。
```

 

**提示：**

- `m == s.length`
- `n == t.length`
- `1 <= m, n <= 105`
- `s` 和 `t` 由英文字母组成

 

**进阶：**你能设计一个在 `o(m+n)` 时间内解决此问题的算法吗？



==*代码*==

```c++
class Solution {
public:
    string minWindow(string s, string t) {
        unordered_map<char, int> need, window;
        for (char c : t) {
            need[c]++;
        }

        int left = 0, right = 0;
        int success = 0;
        int start = 0, len = INT_MAX;
        while (right < s.length()) {
            if (need.count(s[right])) {
                window[s[right]]++;
                if (window[s[right]] == need[s[right]]) {
                    success++;
                }
            }
            right++;

            while (success == need.size()) {
                if (right - left < len) {
                    start = left;
                    len = right - left;
                }
                if (need.count(s[left])) {
                    if (window[s[left]] == need[s[left]]) {
                        success--;
                    }
                    window[s[left]]--;
                }
                left++;
            }
        }
        return len == INT_MAX ? "" : s.substr(start, len);
    }
};
```

