## 博弈

#### 292.Nim游戏(简单)

##### 题目

你和你的朋友，两个人一起玩 Nim 游戏：

- 桌子上有一堆石头。
- 你们轮流进行自己的回合， **你作为先手** 。
- 每一回合，轮到的人拿掉 1 - 3 块石头。
- 拿掉最后一块石头的人就是获胜者。

假设你们每一步都是最优解。请编写一个函数，来判断你是否可以在给定石头数量为 `n` 的情况下赢得游戏。如果可以赢，返回 `true`；否则，返回 `false` 。

**提示：**

- 1 <= n <= pow(2,31) - 1

##### 代码

如果n是4的倍数，则必输，无论你取多少(x)，对手取4-x。

如果n不是4的倍数，则必胜，只要第一步取n%4，后续对手取x，自己取4-x。

```c++
class Solution {
public:
    bool canWinNim(int n) {
        return n % 4 != 0;
    }
};
```

#### 375.猜数字大小(中等)

##### 题目

我们正在玩一个猜数游戏，游戏规则如下：

1. 我从 `1` 到 `n` 之间选择一个数字。
2. 你来猜我选了哪个数字。
3. 如果你猜到正确的数字，就会 **赢得游戏** 。
4. 如果你猜错了，那么我会告诉你，我选的数字比你的 **更大或者更小** ，并且你需要继续猜数。
5. 每当你猜了数字 `x` 并且猜错了的时候，你需要支付金额为 `x` 的现金。如果你花光了钱，就会 **输掉游戏** 。

给你一个特定的数字 `n` ，返回能够 **确保你获胜** 的最小现金数，**不管我选择那个数字** 。

**提示：**

- `1 <= n <= 200`

##### 代码

动态规划,由于计算的是确保获胜的最小现金数,假设第一次猜x,错误

f(1,n) = x + max(f(1,x-1), f(x+1,n))

#### 1025.除数博弈(简单)

##### 题目

爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。

最初，黑板上有一个数字 `n` 。在每个玩家的回合，玩家需要执行以下操作：

- 选出任一 `x`，满足 `0 < x < n` 且 `n % x == 0` 。
- 用 `n - x` 替换黑板上的数字 `n` 。

如果玩家无法执行这些操作，就会输掉游戏。

*只有在爱丽丝在游戏中取得胜利时才返回 `true` 。假设两个玩家都以最佳状态参与游戏。*

**提示：**

- `1 <= n <= 1000`

##### 代码

n = 2, true可选项：1

n = 3, false可选项：1

n = 4, true(选1，给对面3)可选项：1 2

n = 5, false可选项：1

n = 6, true(选1/3，给对面false的数值)可选项：1 2 3

n = 7, false可选项：1

n = 8, true(选1)可选项：1 2 4

n = 9, false可选项：1 3

n = 10, true(选1/5)可选项：1 2 5

n = 11, false可选项：1

n = 12, true(选1/3)可选项：1 2 3 4 6

猜测：偶数赢，奇数输？

n <= 12时成立

假设n <= k时成立，则n=k+1时

当k是偶数时，k+1是奇数，其因数x一定也是奇数，则k+1-x<=k，轮到对方时一定是偶数，所以自己必输

当k是奇数时，k+1是偶数，其因数x可以是奇数也可以是偶数，选择奇数的x(如必然存在的1)，则k+1-x<=k，轮到对方是一定是奇数，所以自己必赢

```c++
class Solution {
public:
    bool divisorGame(int n) {
        return n % 2 == 0;
    }
};
```

