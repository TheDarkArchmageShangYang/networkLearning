# LeetCode

## 数组

### 二分查找

#### 704.二分查找

##### 题目

给定一个 `n` 个元素有序的（升序）整型数组 `nums` 和一个目标值 `target` ，写一个函数搜索 `nums` 中的 `target`，如果目标值存在返回下标，否则返回 `-1`。


**示例 1:**

```
输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4
```

**示例 2:**

```
输入: nums = [-1,0,3,5,9,12], target = 2
输出: -1
解释: 2 不存在 nums 中因此返回 -1
```

 

**提示：**

1.你可以假设 `nums` 中的所有元素是不重复的。

2.`n` 将在 `[1, 10000]`之间。

3.`nums` 的每个元素都将在 `[-9999, 9999]`之间。

##### 代码

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid + 1;
            }
            else if (nums[mid] > target) {
                right = mid - 1;
            }
            else if (nums[mid] == target) {
                return mid;
            }
        }
        return -1;
    }
};
```

相似题目:

35.搜索插入位置

34.在排序数组中查找元素的第一个和最后一个位置

69.x的平方根

367.有效的完全平方数

## 博弈

#### 292.Nim游戏(简单)

##### 题目

你和你的朋友，两个人一起玩 Nim 游戏：

- 桌子上有一堆石头。
- 你们轮流进行自己的回合， **你作为先手** 。
- 每一回合，轮到的人拿掉 1 - 3 块石头。
- 拿掉最后一块石头的人就是获胜者。

假设你们每一步都是最优解。请编写一个函数，来判断你是否可以在给定石头数量为 `n` 的情况下赢得游戏。如果可以赢，返回 `true`；否则，返回 `false` 。

**提示：**

- 1 <= n <= pow(2,31) - 1

##### 代码

如果n是4的倍数，则必输，无论你取多少(x)，对手取4-x。

如果n不是4的倍数，则必胜，只要第一步取n%4，后续对手取x，自己取4-x。

```c++
class Solution {
public:
    bool canWinNim(int n) {
        return n % 4 != 0;
    }
};
```

#### 375.猜数字大小(中等)

##### 题目

我们正在玩一个猜数游戏，游戏规则如下：

1. 我从 `1` 到 `n` 之间选择一个数字。
2. 你来猜我选了哪个数字。
3. 如果你猜到正确的数字，就会 **赢得游戏** 。
4. 如果你猜错了，那么我会告诉你，我选的数字比你的 **更大或者更小** ，并且你需要继续猜数。
5. 每当你猜了数字 `x` 并且猜错了的时候，你需要支付金额为 `x` 的现金。如果你花光了钱，就会 **输掉游戏** 。

给你一个特定的数字 `n` ，返回能够 **确保你获胜** 的最小现金数，**不管我选择那个数字** 。

**提示：**

- `1 <= n <= 200`

##### 代码

动态规划

推导过程

```
dp[i][i] = 0
dp[1][2] = 1
dp[1][3] = 2

dp[1][n] = min(i + max(dp[1][i-1] + dp[i+1][n])) (1 < i < n)
dp[1][n] = i + dp[i+1][n] (i = 1)
dp[1][n] = i + dp[1][i-1] (i = n)
dp[1][4] = min(1+dp[2][4], 2+max(dp[1][1], dp[3][4]), 3+max(dp[1][2], dp[4][4]), 4+dp[1][3])
```

```c++
class Solution {
public:
    int getMoneyAmount(int n) {
        vector<vector<int>> dp(n+1,vector<int>(n+1,0));
        for (int j = 2; j <= n; j++) {
            for (int i = j - 1; i > 0; i--) {
                int ans = INT_MAX;
                for (int k = i + 1; k < j; k++) {
                    ans = min(ans, k + max(dp[i][k-1], dp[k+1][j]));
                }
                ans = min(ans, i + dp[i+1][j]);
                ans = min(ans, j + dp[i][j-1]);
                dp[i][j] = ans;
            }
        }
        return dp[1][n];
    }
};
```

#### 464.我能赢吗(中等)

##### 题目

在 "100 game" 这个游戏中，两名玩家轮流选择从 `1` 到 `10` 的任意整数，累计整数和，先使得累计整数和 **达到或超过** 100 的玩家，即为胜者。

如果我们将游戏规则改为 “玩家 **不能** 重复使用整数” 呢？

例如，两个玩家可以轮流从公共整数池中抽取从 1 到 15 的整数（不放回），直到累计整数和 >= 100。

给定两个整数 `maxChoosableInteger` （整数池中可选择的最大数）和 `desiredTotal`（累计和），若先出手的玩家能稳赢则返回 `true` ，否则返回 `false` 。假设两位玩家游戏时都表现 **最佳** 。

**提示:**

- `1 <= maxChoosableInteger <= 20`
- `0 <= desiredTotal <= 300`

##### 代码

#### 1025.除数博弈(简单)

##### 题目

爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。

最初，黑板上有一个数字 `n` 。在每个玩家的回合，玩家需要执行以下操作：

- 选出任一 `x`，满足 `0 < x < n` 且 `n % x == 0` 。
- 用 `n - x` 替换黑板上的数字 `n` 。

如果玩家无法执行这些操作，就会输掉游戏。

*只有在爱丽丝在游戏中取得胜利时才返回 `true` 。假设两个玩家都以最佳状态参与游戏。*

**提示：**

- `1 <= n <= 1000`

##### 代码

n = 2, true可选项：1

n = 3, false可选项：1

n = 4, true(选1，给对面3)可选项：1 2

n = 5, false可选项：1

n = 6, true(选1/3，给对面false的数值)可选项：1 2 3

n = 7, false可选项：1

n = 8, true(选1)可选项：1 2 4

n = 9, false可选项：1 3

n = 10, true(选1/5)可选项：1 2 5

n = 11, false可选项：1

n = 12, true(选1/3)可选项：1 2 3 4 6

猜测：偶数赢，奇数输？

n <= 12时成立

假设n <= k时成立，则n=k+1时

当k是偶数时，k+1是奇数，其因数x一定也是奇数，则k+1-x<=k，轮到对方时一定是偶数，所以自己必输

当k是奇数时，k+1是偶数，其因数x可以是奇数也可以是偶数，选择奇数的x(如必然存在的1)，则k+1-x<=k，轮到对方是一定是奇数，所以自己必赢

```c++
class Solution {
public:
    bool divisorGame(int n) {
        return n % 2 == 0;
    }
};
```

