# 并查集

## 基本原理

并查集提供以下API(最初级版本):

```c++
struct UnionFindNode {
    // 节点 id编号
    int id;
    // 指向父节点的指针
    UnionFindNode parent;
}
class UnionFind {
    // 初始化并查集，包含 n 个节点，时间复杂度 O(n)
    public UnionFind(int n);

    // 连接节点 p 和节点 q，时间复杂度 O(1)
    public void union(UnionFindNode p, UnionFindNode q) {
        find(p).parent = find(q);
    }

    // 查询节点 p 和节点 q 是否连通（是否在同一个连通分量内），时间复杂度 O(1)
    public boolean connected(UnionFindNode p, UnionFindNode q) {
        return find(p).id == find(q).id;
    }

    // 查询当前的连通分量数量，时间复杂度 O(1)
    public int count();
}
UnionFindNode find(UnionFindNode node) {
    while (node.parent != nullptr) {
        node = node.parent;
    }
    return node;
}
```

并查集能在 ${O(1)}$ 时间内完成 `union()` 和 `connected()`

并查集底层其实是一片森林（若干棵多叉树），每棵树代表一个连通分量： 

- connected(p, q)：只需要判断 p 和 q 所在的多叉树的根节点，若相同，则 p 和 q 在同一棵树中，即连通，否则不连通。 
- count()：只需要统计一下总共有多少棵树，即可得到连通分量的数量。 
- union(p, q)：只需要将 p 节点所在的这棵树的根节点，接入到 q 节点所在的这棵树的根节点下面，即可完成连接操作。注意这里并不是 p, q 两个节点的合并，而是两棵树根节点的合并。因为 p, q 一旦连通，那么他们所属的连通分量就合并成了同一个更大的连通分量。

为了防止union操作让森林退化成链表,可以使用以下方法优化:

- 权重数组: 每次union操作都是把节点个数较多的树接到节点个数较少的树下面
- 路径压缩: 一旦触发,无论树枝高度多少,都会被压缩为2,且压缩的均摊复杂度为${O(1)}$



## 实现

```c++
class UnionFind {
private:
    // 记录连通分量
    int _count;
    // 节点 x 的父节点是 parent[x]
    vector<int> parent;
    // 返回某个节点 x 的根节点
    // 普通版本
    int find(int x) {
        // 根节点的 parent[x] == x
        while (parent[x] != x)
            x = parent[x];
        return x;
    }
    // 路径压缩
    int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }
public:
    // 构造函数，n 为图的节点总数
    UnionFind(int n) {
        // 一开始互不连通
        this->_count = n;
        // 父节点指针初始指向自己
        parent = vector<int>(n);
        for (int i = 0; i < n; i++)
            parent[i] = i;
    }
    int count() {
        return _count;
    }
    void _union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ) return;
        // 将两棵树合并为一棵
        parent[rootP] = rootQ;
        _count--;
    }
    bool connected(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        return rootP == rootQ;
    }
};
```



## 例题

### 990.[等式方程的可满足性](https://leetcode.cn/problems/satisfiability-of-equality-equations/description/)

给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 `equations[i]` 的长度为 `4`，并采用两种不同的形式之一：`"a==b"` 或 `"a!=b"`。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。

只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 `true`，否则返回 `false`。 

 



**示例 1：**

```
输入：["a==b","b!=a"]
输出：false
解释：如果我们指定，a = 1 且 b = 1，那么可以满足第一个方程，但无法满足第二个方程。没有办法分配变量同时满足这两个方程。
```

**示例 2：**

```
输入：["b==a","a==b"]
输出：true
解释：我们可以指定 a = 1 且 b = 1 以满足满足这两个方程。
```

**示例 3：**

```
输入：["a==b","b==c","a==c"]
输出：true
```

**示例 4：**

```
输入：["a==b","b!=c","c==a"]
输出：false
```

**示例 5：**

```
输入：["c==c","b==d","x!=z"]
输出：true
```

 

**提示：**

1. `1 <= equations.length <= 500`
2. `equations[i].length == 4`
3. `equations[i][0]` 和 `equations[i][3]` 是小写字母
4. `equations[i][1]` 要么是 `'='`，要么是 `'!'`
5. `equations[i][2]` 是 `'='`



==**代码**==

```c++
class UnionFind {
private:
    int _count;
    vector<int> parent;
    int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }
public:
    UnionFind(int n) {
        this->_count = n;
        parent.resize(n);
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
    }
    int count() {
        return _count;
    }
    void _union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ) return;
        parent[rootP] = rootQ;
        _count--;
    }
    bool connected(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        return rootP == rootQ;
    }
};
class Solution {
public:
    bool equationsPossible(vector<string>& equations) {
        UnionFind uf;
        for (auto& str : equations) {
            if (str[1] == '=') {
                uf._union(str[0] - 'a', str[3] - 'a');
            }
        }
        for (auto& str : equations) {
            if (str[1] == '!' && uf.find(str[0] - 'a') == uf.find(str[3] - 'a')) {
                return false;
            }
        }
        return true;
    }
};
```



### 547.[省份数量](https://leetcode.cn/problems/number-of-provinces/description/)

有 `n` 个城市，其中一些彼此相连，另一些没有相连。如果城市 `a` 与城市 `b` 直接相连，且城市 `b` 与城市 `c` 直接相连，那么城市 `a` 与城市 `c` 间接相连。

**省份** 是一组直接或间接相连的城市，组内不含其他没有相连的城市。

给你一个 `n x n` 的矩阵 `isConnected` ，其中 `isConnected[i][j] = 1` 表示第 `i` 个城市和第 `j` 个城市直接相连，而 `isConnected[i][j] = 0` 表示二者不直接相连。

返回矩阵中 **省份** 的数量。

 

**示例 1：**

![img](https://fzchen-picgo.oss-cn-shanghai.aliyuncs.com/Github/learning/20250129235940787.jpeg)

```
输入：isConnected = [[1,1,0],[1,1,0],[0,0,1]]
输出：2
```

**示例 2：**

![img](https://fzchen-picgo.oss-cn-shanghai.aliyuncs.com/Github/learning/20250129235940705.jpeg)

```
输入：isConnected = [[1,0,0],[0,1,0],[0,0,1]]
输出：3
```

 

**提示：**

- `1 <= n <= 200`
- `n == isConnected.length`
- `n == isConnected[i].length`
- `isConnected[i][j]` 为 `1` 或 `0`
- `isConnected[i][i] == 1`
- `isConnected[i][j] == isConnected[j][i]`



==**代码**==

```c++
class UnionFind {
private:
    int _count;
    vector<int> parent;
    int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }
public:
    UnionFind(int n) {
        this->_count = n;
        parent.resize(n);
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
    }
    int count() {
        return _count;
    }
    void _union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ) return;
        parent[rootP] = rootQ;
        _count--;
    }
    bool connected(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        return rootP == rootQ;
    }
};
class Solution {
public:
    int findCircleNum(vector<vector<int>>& isConnected) {
        int n = isConnected.size();
        UnionFind uf(n);
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (isConnected[i][j] == 1) {
                    uf._union(i, j);
                }
            }
        }
        return uf.count();
    }
};
```



### 1361.[验证二叉树](https://leetcode.cn/problems/validate-binary-tree-nodes/description/)

二叉树上有 `n` 个节点，按从 `0` 到 `n - 1` 编号，其中节点 `i` 的两个子节点分别是 `leftChild[i]` 和 `rightChild[i]`。

只有 **所有** 节点能够形成且 **只** 形成 **一颗** 有效的二叉树时，返回 `true`；否则返回 `false`。

如果节点 `i` 没有左子节点，那么 `leftChild[i]` 就等于 `-1`。右子节点也符合该规则。

注意：节点没有值，本问题中仅仅使用节点编号。

 

**示例 1：**

**![img](https://fzchen-picgo.oss-cn-shanghai.aliyuncs.com/Github/learning/20250130001212969.png)**

```
输入：n = 4, leftChild = [1,-1,3,-1], rightChild = [2,-1,-1,-1]
输出：true
```

**示例 2：**

**![img](https://fzchen-picgo.oss-cn-shanghai.aliyuncs.com/Github/learning/20250130001212978.png)**

```
输入：n = 4, leftChild = [1,-1,3,-1], rightChild = [2,3,-1,-1]
输出：false
```

**示例 3：**

**![img](https://fzchen-picgo.oss-cn-shanghai.aliyuncs.com/Github/learning/20250130001212987.png)**

```
输入：n = 2, leftChild = [1,0], rightChild = [-1,-1]
输出：false
```

 

**提示：**

- `n == leftChild.length == rightChild.length`
- `1 <= n <= 10^4`
- `-1 <= leftChild[i], rightChild[i] <= n - 1`



==**代码**==

```c++
class UnionFind {
private:
    int _count;
    vector<int> parent;
    int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }
public:
    UnionFind(int n) {
        this->_count = n;
        parent.resize(n);
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
    }
    int count() {
        return _count;
    }
    void _union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ) return;
        parent[rootP] = rootQ;
        _count--;
    }
    bool connected(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        return rootP == rootQ;
    }
};
class Solution {
public:
    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {
        vector<int> indegree(n);
        for (int i = 0; i < n; i++) {
            if (leftChild[i] != -1) {
                indegree[leftChild[i]]++;
            }
            if (rightChild[i] != -1) {
                indegree[rightChild[i]]++;
            }
        }
        int root = -1;
        for (int i = 0; i < n; i++) {
            if (indegree[i] == 0) {
                if (root != -1) return false;
                root = i;
            } else if (indegree[i] != 1) {
                return false;
            }
        }
        if (root == -1) return false;
        
        UnionFind uf(n);
        for (int i = 0; i < n; i++) {
            if (leftChild[i] != -1) {
                if (uf.connected(i, leftChild[i])) return false;
                uf._union(i, leftChild[i]);
            }
            if (rightChild[i] != -1) {
                if (uf.connected(i, rightChild[i])) return false;
                uf._union(i, rightChild[i]);
            }
        }
        return uf.count() == 1;
    }
};
```



### 947.[移除最多的同行或同列石头](https://leetcode.cn/problems/most-stones-removed-with-same-row-or-column/description/)

`n` 块石头放置在二维平面中的一些整数坐标点上。每个坐标点上最多只能有一块石头。

如果一块石头的 **同行或者同列** 上有其他石头存在，那么就可以移除这块石头。

给你一个长度为 `n` 的数组 `stones` ，其中 `stones[i] = [xi, yi]` 表示第 `i` 块石头的位置，返回 **可以移除的石子** 的最大数量。

 

**示例 1：**

```
输入：stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]
输出：5
解释：一种移除 5 块石头的方法如下所示：
1. 移除石头 [2,2] ，因为它和 [2,1] 同行。
2. 移除石头 [2,1] ，因为它和 [0,1] 同列。
3. 移除石头 [1,2] ，因为它和 [1,0] 同行。
4. 移除石头 [1,0] ，因为它和 [0,0] 同列。
5. 移除石头 [0,1] ，因为它和 [0,0] 同行。
石头 [0,0] 不能移除，因为它没有与另一块石头同行/列。
```

**示例 2：**

```
输入：stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]
输出：3
解释：一种移除 3 块石头的方法如下所示：
1. 移除石头 [2,2] ，因为它和 [2,0] 同行。
2. 移除石头 [2,0] ，因为它和 [0,0] 同列。
3. 移除石头 [0,2] ，因为它和 [0,0] 同行。
石头 [0,0] 和 [1,1] 不能移除，因为它们没有与另一块石头同行/列。
```

**示例 3：**

```
输入：stones = [[0,0]]
输出：0
解释：[0,0] 是平面上唯一一块石头，所以不可以移除它。
```

 

**提示：**

- `1 <= stones.length <= 1000`
- `0 <= xi, yi <= 10^4`
- 不会有两块石头放在同一个坐标点上



==**代码**==

```c++
class UnionFind {
private:
    int _count;
    vector<int> parent;
    int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }
public:
    UnionFind(int n) {
        this->_count = n;
        parent.resize(n);
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
    }
    int count() {
        return _count;
    }
    void _union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ) return;
        parent[rootP] = rootQ;
        _count--;
    }
    bool connected(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        return rootP == rootQ;
    }
};
class Solution {
public:
    int removeStones(vector<vector<int>>& stones) {
        int n = stones.size();
        UnionFind uf(n);
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (stones[i][0] == stones[j][0] || stones[i][1] == stones[j][1]) {
                    uf._union(i, j);
                }
            }
        }
        return n - uf.count();
    }
};
```

