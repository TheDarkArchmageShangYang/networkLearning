# 位运算

## 常见操作

```c++
// 1. 利用或操作 `|` 和空格将英文字符转换为小写
('a' | ' ') = 'a'
('A' | ' ') = 'a'

// 2. 利用与操作 `&` 和下划线将英文字符转换为大写
('b' & '_') = 'B'
('B' & '_') = 'B'

// 3. 利用异或操作 `^` 和空格进行英文字符大小写互换
('d' ^ ' ') = 'D'
('D' ^ ' ') = 'd'

// 4. 不用临时变量交换两个数
int a = 1, b = 2;
a ^= b;
b ^= a;
a ^= b; // 现在 a = 2, b = 1


// 5. 加一
int n = 1;
n = -~n; // 现在 n = 2


// 6. 减一
int n = 2;
n = ~-n; // 现在 n = 1


// 7. 判断两个数是否异号
int x = -1, y = 2;
bool f = ((x ^ y) < 0); // true

int x = 3, y = 2;
bool f = ((x ^ y) < 0); // false

// 8. 判断循环数组索引(只适用与数组长度为2^k)
int arr[] = {1, 2, 3, 4};
// 使用 % 符号(开销比较高)
index = i % (sizeof(arr) / sizeof(int));
// 位运算
index = i & (arr.size() - 1);

// 9. 消除数字n的二进制表示的最后一个1
n &  (n - 1);

// 10. 任何数和它本身进行异或运算结果为0
// 任何数和0进行异或运算结果为它本身
a ^ a == 0;
a ^ 0 == a;
```



## 例题

### 191.[位1的个数](https://leetcode.cn/problems/number-of-1-bits/description/)

给定一个正整数 `n`，编写一个函数，获取一个正整数的二进制形式并返回其二进制表达式中 设置位 的个数（也被称为[汉明重量](https://baike.baidu.com/item/汉明重量)）。

 

**示例 1：**

```
输入：n = 11
输出：3
解释：输入的二进制串 1011 中，共有 3 个设置位。
```

**示例 2：**

```
输入：n = 128
输出：1
解释：输入的二进制串 10000000 中，共有 1 个设置位。
```

**示例 3：**

```
输入：n = 2147483645
输出：30
解释：输入的二进制串 1111111111111111111111111111101 中，共有 30 个设置位。
```

 

**提示：**

- `1 <= n <= 231 - 1`



 

**进阶**：

- 如果多次调用这个函数，你将如何优化你的算法？



==**代码**==

```c++
class Solution {
public:
    int hammingWeight(int n) {
        int ans = 0;
        while (n > 0) {
            ans++;
            n = n & (n - 1);
        }
        return ans;
    }
};
```



### 231.[2的幂](https://leetcode.cn/problems/power-of-two/description/)

给你一个整数 `n`，请你判断该整数是否是 2 的幂次方。如果是，返回 `true` ；否则，返回 `false` 。

如果存在一个整数 `x` 使得 `n == 2x` ，则认为 `n` 是 2 的幂次方。

 

**示例 1：**

```
输入：n = 1
输出：true
解释：20 = 1
```

**示例 2：**

```
输入：n = 16
输出：true
解释：24 = 16
```

**示例 3：**

```
输入：n = 3
输出：false
```

 

**提示：**

- `-231 <= n <= 231 - 1`

 

**进阶：**你能够不使用循环/递归解决此问题吗？



==**代码**==

```c++
class Solution {
public:
    bool isPowerOfTwo(int n) {
        if (n <= 0) return false;
        if ((n & (n - 1)) > 0) return false;
        return true;
    }
};
```



### 136.[只出现一次的数字](https://leetcode.cn/problems/single-number/description/)

给你一个 **非空** 整数数组 `nums` ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。

 

**示例 1 ：**

**输入：**nums = [2,2,1]

**输出：**1

**示例 2 ：**

**输入：**nums = [4,1,2,1,2]

**输出：**4

**示例 3 ：**

**输入：**nums = [1]

**输出：**1

 

**提示：**

- `1 <= nums.length <= 3 * 104`
- `-3 * 104 <= nums[i] <= 3 * 104`
- 除了某个元素只出现一次以外，其余每个元素均出现两次。



==**代码**==

```c++
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int ans = 0;
        for (int num : nums) {
            ans ^= num;
        }
        return ans;
    }
};
```



### 268.[丢失的数字](https://leetcode.cn/problems/missing-number/description/)

给定一个包含 `[0, n]` 中 `n` 个数的数组 `nums` ，找出 `[0, n]` 这个范围内没有出现在数组中的那个数。



 

**示例 1：**

**输入：**nums = [3,0,1]

**输出：**2

**解释：**`n = 3`，因为有 3 个数字，所以所有的数字都在范围 `[0,3]` 内。2 是丢失的数字，因为它没有出现在 `nums` 中。

**示例 2：**

**输入：**nums = [0,1]

**输出：**2

**解释：**`n = 2`，因为有 2 个数字，所以所有的数字都在范围 `[0,2]` 内。2 是丢失的数字，因为它没有出现在 `nums` 中。

**示例 3：**

**输入：**nums = [9,6,4,2,3,5,7,0,1]

**输出：**8

**解释：**`n = 9`，因为有 9 个数字，所以所有的数字都在范围 `[0,9]` 内。8 是丢失的数字，因为它没有出现在 `nums` 中。

**提示：**

- `n == nums.length`
- `1 <= n <= 104`
- `0 <= nums[i] <= n`
- `nums` 中的所有数字都 **独一无二**

 

**进阶：**你能否实现线性时间复杂度、仅使用额外常数空间的算法解决此问题?



==**代码**==

```c++
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        int n = nums.size();
        int ans = n;
        for (int i = 0; i < n; i++) {
            ans ^= i ^ nums[i];
        }
        return ans;
    }
};
```

