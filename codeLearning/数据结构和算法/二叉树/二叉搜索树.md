# 二叉搜索树

二叉搜索树(Binary Search Tree, 简称BST):

对于树中的每个节点:

- 其==左子树的所有节点==的值小于当前节点的值
- 其==右子树的所有节点==的值大于当前节点的值

二叉搜索树的中序遍历结果有序

增删改查时间复杂度为$O(log N)$

## 例题

### 700.[二叉搜索树中的搜索](https://leetcode.cn/problems/search-in-a-binary-search-tree/description/)

给定二叉搜索树（BST）的根节点 `root` 和一个整数值 `val`。

你需要在 BST 中找到节点值等于 `val` 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 `null` 。

 

**示例 1:**

<img src="https://fzchen-picgo.oss-cn-shanghai.aliyuncs.com/Github/learning/20250108005327036.jpeg" alt="img" style="zoom:67%;" />

```
输入：root = [4,2,7,1,3], val = 2
输出：[2,1,3]
```

**示例 2:**

<img src="https://fzchen-picgo.oss-cn-shanghai.aliyuncs.com/Github/learning/20250108005327382.jpeg" alt="img" style="zoom:67%;" />

```
输入：root = [4,2,7,1,3], val = 5
输出：[]
```

 

**提示：**

- 树中节点数在 `[1, 5000]` 范围内
- `1 <= Node.val <= 10^7`
- `root` 是二叉搜索树
- `1 <= val <= 10^7`



==**代码**==

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        if (root == nullptr) {
            return nullptr;
        }
        if (root->val == val) {
            return root;
        }
        return root->val > val ? searchBST(root->left, val) : searchBST(root->right, val);
    }
};
```



### 669.[修剪二叉搜索树](https://leetcode.cn/problems/trim-a-binary-search-tree/description/)

给你二叉搜索树的根节点 `root` ，同时给定最小边界`low` 和最大边界 `high`。通过修剪二叉搜索树，使得所有节点的值在`[low, high]`中。修剪树 **不应该** 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 **唯一的答案** 。

所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。

 

**示例 1：**

<img src="https://fzchen-picgo.oss-cn-shanghai.aliyuncs.com/Github/learning/20250108135514579.jpeg" alt="img" style="zoom:67%;" />

```
输入：root = [1,0,2], low = 1, high = 2
输出：[1,null,2]
```

**示例 2：**

<img src="https://fzchen-picgo.oss-cn-shanghai.aliyuncs.com/Github/learning/20250108135514810.jpeg" alt="img" style="zoom:67%;" />

```
输入：root = [3,0,4,null,2,null,null,1], low = 1, high = 3
输出：[3,2,null,1]
```

 

**提示：**

- 树中节点数在范围 `[1, 10^4]` 内
- `0 <= Node.val <= 10^4`
- 树中每个节点的值都是 **唯一** 的
- 题目数据保证输入是一棵有效的二叉搜索树
- `0 <= low <= high <= 10^4`



==**代码**==

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* trimBST(TreeNode* root, int low, int high) {
        if (root == nullptr) {
            return nullptr;
        }
        if (root->val < low) {
            return trimBST(root->right, low, high);
        } else if (root->val > high) {
            return trimBST(root->left, low, high);
        }
        root->left = trimBST(root->left, low, high);
        root->right = trimBST(root->right, low, high);
        return root;
    }
};
```



### 671.[二叉树中第二小的节点](https://leetcode.cn/problems/second-minimum-node-in-a-binary-tree/description/)

给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 `2` 或 `0`。如果一个节点有两个子节点的话，那么该节点的值等于两个子节点中较小的一个。

更正式地说，即 `root.val = min(root.left.val, root.right.val)` 总成立。

给出这样的一个二叉树，你需要输出所有节点中的 **第二小的值** 。

如果第二小的值不存在的话，输出 -1 **。**

 

**示例 1：**

<img src="https://fzchen-picgo.oss-cn-shanghai.aliyuncs.com/Github/learning/20250108141317180.jpeg" alt="img" style="zoom:67%;" />

```
输入：root = [2,2,5,null,null,5,7]
输出：5
解释：最小的值是 2 ，第二小的值是 5 。
```

**示例 2：**

<img src="https://fzchen-picgo.oss-cn-shanghai.aliyuncs.com/Github/learning/20250108141317156.jpeg" alt="img" style="zoom:80%;" />

```
输入：root = [2,2,2]
输出：-1
解释：最小的值是 2, 但是不存在第二小的值。
```

 

**提示：**

- 树中节点数目在范围 `[1, 25]` 内
- `1 <= Node.val <= 2^31 - 1`
- 对于树中每个节点 `root.val == min(root.left.val, root.right.val)`



==**代码**==

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),
 * right(right) {}
 * };
 */
class Solution {
public:
    int minNum;
    int secondMinNum = -1;
    int findSecondMinimumValue(TreeNode * root) {
        if (root == nullptr) {
            return -1;
        }
        minNum = root->val;
        dfs(root);
        return secondMinNum;
    }
    void dfs(TreeNode* root) {
        if (root == nullptr) {
            return;
        }
        if (secondMinNum == -1 && root->val > minNum) {
            secondMinNum = root->val;
            return;
        }
        if (root->val > minNum) {
            secondMinNum = min(secondMinNum, root->val);
            return;
        }
        dfs(root->left);
        dfs(root->right);
    }
};
```



### 99.[恢复二叉搜索树](https://leetcode.cn/problems/recover-binary-search-tree/description/)

给你二叉搜索树的根节点 `root` ，该树中的 **恰好** 两个节点的值被错误地交换。*请在不改变其结构的情况下，恢复这棵树* 。

 

**示例 1：**

<img src="https://fzchen-picgo.oss-cn-shanghai.aliyuncs.com/Github/learning/20250108004107222.jpeg" alt="img" style="zoom:67%;" />

```
输入：root = [1,3,null,null,2]
输出：[3,1,null,null,2]
解释：3 不能是 1 的左孩子，因为 3 > 1 。交换 1 和 3 使二叉搜索树有效。
```

**示例 2：**

<img src="https://fzchen-picgo.oss-cn-shanghai.aliyuncs.com/Github/learning/20250108004106971.jpeg" alt="img" style="zoom:67%;" />

```
输入：root = [3,1,4,null,null,2]
输出：[2,1,4,null,null,3]
解释：2 不能在 3 的右子树中，因为 2 < 3 。交换 2 和 3 使二叉搜索树有效。
```

 

**提示：**

- 树上节点的数目在范围 `[2, 1000]` 内
- `-2^31 <= Node.val <= 2^31 - 1`



**进阶：**使用 `O(n)` 空间复杂度的解法很容易实现。你能想出一个只使用 `O(1)` 空间的解决方案吗？



==**代码**==

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* node1 = nullptr;
    TreeNode* node2 = nullptr;
    TreeNode* prev = new TreeNode(INT_MIN);
    void recoverTree(TreeNode* root) {
        dfs(root);
        int tmp = node1->val;
        node1->val = node2->val;
        node2->val = tmp;
    }
    void dfs(TreeNode* root) {
        if (root == nullptr) {
            return;
        }
        dfs(root->left);
        if (root->val < prev->val) {
            if (node1 == nullptr) {
                node1 = prev;
            }
            node2 = root;
        }
        prev = root;
        dfs(root->right);
    }
};
```
