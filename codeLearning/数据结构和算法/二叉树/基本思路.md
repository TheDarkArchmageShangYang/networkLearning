# 基本思路

## 基本思路

二叉树的问题通常需要遍历整棵树,可以考虑常见的遍历方法:

- 动态规划
  - 将复杂问题分解为子问题
  - 主要关注子树
- 回溯算法
  - 与回溯算法基本相同,代码结构也基本相同,不需要刻意区分,以下全使用DFS
  - 主要关注树枝(根节点与左右子树的关系,而不是其中任何一个节点)
- 深度优先搜索(DFS)
  - 主要关注当前节点
- 广度优先搜索(BFS)
  - 层序遍历二叉树

面对一个问题:

1.判断使用DFS/动态规划来写递归

- 是否能够通过一次遍历二叉树来完成
- 是否能够将原问题分解为多个子问题

2.判断在==前序/中序/后序/层序==中写代码

前序只能获取当前节点的数据

中序可以获取当前节点和左子树的数据

后序可以获取当前节点和左右子树的数据

所以如果题目中需要用到子树,一般在后序修改代码,不需要子树则在前序修改代码

自顶向下DFS和自底向上DFS的区别:

- 自顶向下先处理当前节点,再递归子节点(前序位置)
- 自底向上先递归子节点,再处理当前节点(后序位置)

递归与以上的区别:

- 递归是以上算法的一种实现方式,是思想而不是算法
- 以上算法可以不使用递归,而使用迭代实现.只是很多情况下递归的代码更简洁明了

## 题单

1. DFS
   - 226.[翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/description/)
   - 257.[二叉树的所有路径](https://leetcode.cn/problems/binary-tree-paths/description/)
   - 129.[求根节点到叶节点数字之和](https://leetcode.cn/problems/sum-root-to-leaf-numbers/description/)
   - 988.[从叶结点开始的最小字符串](https://leetcode.cn/problems/smallest-string-starting-from-leaf/description/)
   - 1022.[从根到叶的二进制数之和](https://leetcode.cn/problems/sum-of-root-to-leaf-binary-numbers/description/)
   - 1457.[二叉树中的伪回文路径](https://leetcode.cn/problems/pseudo-palindromic-paths-in-a-binary-tree/description/)
   - 404.[左叶子之和](https://leetcode.cn/problems/sum-of-left-leaves/description/)
   - 971.[翻转二叉树以匹配先序遍历](https://leetcode.cn/problems/flip-binary-tree-to-match-preorder-traversal/description/)
   - 987.[二叉树的垂序遍历](https://leetcode.cn/problems/vertical-order-traversal-of-a-binary-tree/description/)
   - 993.[二叉树的堂兄弟节点](https://leetcode.cn/problems/cousins-in-binary-tree/description/)
   - 1315.[祖父节点值为偶数的节点和](https://leetcode.cn/problems/sum-of-nodes-with-even-valued-grandparent/description/)
2. BFS
3. 构造二叉树
   - 654.[最大二叉树](https://leetcode.cn/problems/maximum-binary-tree/description/)
   - 105.[从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/)
   - 106.[从中序与后序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/)
   - 889.[根据前序和后序遍历构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/description/)



226,257,129,988,1022,1457,404相似,均为遍历二叉树的所有路径

971需要根据先序遍历进行处理

987需要记录每个节点的深度,宽度,值

993,1315需要记录父节点/祖父节点

## 深度优先搜索

### 基本模板

DFS题目可以以`二叉树的所有路径`为模板,在`ans`,`path`,`叶子节点的特殊行动`等部分进行修改

```c++
class Solution {
public:
    vector<string> ans;
    vector<string> function(TreeNode* root) {
        traverse(root, "");
        return ans;
    }
    void traverse(TreeNode* root, string path) {
        if (root == nullptr) {
            return;
        }
        path += to_string(root->val);
        if (root->left == nullptr && root->right == nullptr) {
            ans.push_back(path);
            return;
        }
        path += "->";
        traverse(root->left, path);
        traverse(root->right, path);
    }
};
```



### 例题

#### 226.[翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/description/)

给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。

 

**示例 1：**

![img](https://fzchen-picgo.oss-cn-shanghai.aliyuncs.com/Github/learning/20241218221646831.jpeg)

```
输入：root = [4,2,7,1,3,6,9]
输出：[4,7,2,9,6,3,1]
```

**示例 2：**

![img](https://fzchen-picgo.oss-cn-shanghai.aliyuncs.com/Github/learning/20241218221646813.jpeg)

```
输入：root = [2,1,3]
输出：[2,3,1]
```

**示例 3：**

```
输入：root = []
输出：[]
```

 

**提示：**

- 树中节点数目范围在 `[0, 100]` 内
- `-100 <= Node.val <= 100`



==**代码**==

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        traverse(root);
        return root;
    }
    void traverse(TreeNode* root) {
        if (root == nullptr) return;
        
        TreeNode* tmp = root->left;
        root->left = root->right;
        root->right = tmp;
        
        traverse(root->left);
        traverse(root->right);
    }
};
```



分解问题

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if (root == nullptr) {
            return root;
        }
        TreeNode* left = invertTree(root->left);
        TreeNode* right = invertTree(root->right);

        root->left = right;
        root->right = left;
        return root;
    }
};
```



#### 257.[二叉树的所有路径](https://leetcode.cn/problems/binary-tree-paths/description/)

给你一个二叉树的根节点 `root` ，按 **任意顺序** ，返回所有从根节点到叶子节点的路径。

**叶子节点** 是指没有子节点的节点。

 

**示例 1：**

![img](https://fzchen-picgo.oss-cn-shanghai.aliyuncs.com/Github/learning/20241222193542316.jpeg)

```
输入：root = [1,2,3,null,5]
输出：["1->2->5","1->3"]
```

**示例 2：**

```
输入：root = [1]
输出：["1"]
```

 

**提示：**

- 树中节点的数目在范围 `[1, 100]` 内
- `-100 <= Node.val <= 100`



==**代码**==

1. 首先考虑这道题用dp还是dfs,两种方法都可以.考虑到dp会使用大量`vector<string>`,所以选择用dfs

2. 然后考虑在什么位置记录当前节点,由于左右子树需要知道父亲节点的数字,所以在前序位置记录当前节点

3. 考虑dfs终止条件,除了常规的遍历空指针时,还需要在访问到叶子节点时记录整条路径

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<string> ans;
    vector<string> binaryTreePaths(TreeNode* root) {
        traverse(root, "");
        return ans;
    }
    void traverse(TreeNode* root, string path) {
        if (root == nullptr) {
            return;
        }
        path += to_string(root->val);
        if (root->left == nullptr && root->right == nullptr) {
            ans.push_back(path);
            return;
        }
        path += "->";
        traverse(root->left, path);
        traverse(root->right, path);
    }
};
```



#### 129.[求根节点到叶节点数字之和](https://leetcode.cn/problems/sum-root-to-leaf-numbers/description/)

给你一个二叉树的根节点 `root` ，树中每个节点都存放有一个 `0` 到 `9` 之间的数字。

每条从根节点到叶节点的路径都代表一个数字：

- 例如，从根节点到叶节点的路径 `1 -> 2 -> 3` 表示数字 `123` 。

计算从根节点到叶节点生成的 **所有数字之和** 。

**叶节点** 是指没有子节点的节点。

 

**示例 1：**

![img](https://fzchen-picgo.oss-cn-shanghai.aliyuncs.com/Github/learning/20241222200133967.jpeg)

```
输入：root = [1,2,3]
输出：25
解释：
从根到叶子节点路径 1->2 代表数字 12
从根到叶子节点路径 1->3 代表数字 13
因此，数字总和 = 12 + 13 = 25
```

**示例 2：**

![img](https://fzchen-picgo.oss-cn-shanghai.aliyuncs.com/Github/learning/20241222200133991.jpeg)

```
输入：root = [4,9,0,5,1]
输出：1026
解释：
从根到叶子节点路径 4->9->5 代表数字 495
从根到叶子节点路径 4->9->1 代表数字 491
从根到叶子节点路径 4->0 代表数字 40
因此，数字总和 = 495 + 491 + 40 = 1026
```

 

**提示：**

- 树中节点的数目在范围 `[1, 1000]` 内
- `0 <= Node.val <= 9`
- 树的深度不超过 `10`



==**代码**==

与257基本一致

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int ans = 0;
    int sumNumbers(TreeNode* root) {
        traverse(root, 0);
        return ans;
    }
    void traverse(TreeNode* root, int sum) {
        if (root == nullptr) {
            return;
        }
        sum = sum * 10 + root->val;
        if (root->left == nullptr && root->right == nullptr) {
            ans += sum;
            return;
        } 
        traverse(root->left, sum);
        traverse(root->right, sum);
    }
};
```



#### 988.[从叶结点开始的最小字符串](https://leetcode.cn/problems/smallest-string-starting-from-leaf/description/)

给定一颗根结点为 `root` 的二叉树，树中的每一个结点都有一个 `[0, 25]` 范围内的值，分别代表字母 `'a'` 到 `'z'`。

返回 ***按字典序最小** 的字符串，该字符串从这棵树的一个叶结点开始，到根结点结束*。

> 注**：**字符串中任何较短的前缀在 **字典序上** 都是 **较小** 的：
>
> - 例如，在字典序上 `"ab"` 比 `"aba"` 要小。叶结点是指没有子结点的结点。 

节点的叶节点是没有子节点的节点。

 



**示例 1：**

**<img src="https://fzchen-picgo.oss-cn-shanghai.aliyuncs.com/Github/learning/20241223022025797.png" alt="img" style="zoom:50%;" />**

```
输入：root = [0,1,2,3,4,3,4]
输出："dba"
```

**示例 2：**

<img src="https://fzchen-picgo.oss-cn-shanghai.aliyuncs.com/Github/learning/20241223022027542.png" alt="img" style="zoom:50%;" />

```
输入：root = [25,1,3,1,3,0,2]
输出："adz"
```

**示例 3：**

<img src="https://fzchen-picgo.oss-cn-shanghai.aliyuncs.com/Github/learning/20241223022027695.png" alt="img" style="zoom:50%;" />

```
输入：root = [2,2,1,null,1,0,null,0]
输出："abc"
```

 

**提示：**

- 给定树的结点数在 `[1, 8500]` 范围内
- `0 <= Node.val <= 25`



==**代码**==

与257基本相同

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    string ans;
    string smallestFromLeaf(TreeNode* root) {
        traverse(root, "");
        return ans;
    }
    void traverse(TreeNode* root, string str) {
        if (root == nullptr) {
            return;
        }
        str += 'a' + root->val;
        if (root->left == nullptr && root->right == nullptr) {
            reverse(str.begin(), str.end());
            if (ans.empty() || str.compare(ans) <= 0) {
                ans = str;
            }
            return;
        }
        traverse(root->left, str);
        traverse(root->right, str);

    }
};
```



#### 1022.[从根到叶的二进制数之和](https://leetcode.cn/problems/sum-of-root-to-leaf-binary-numbers/description/)

给出一棵二叉树，其上每个结点的值都是 `0` 或 `1` 。每一条从根到叶的路径都代表一个从最高有效位开始的二进制数。

- 例如，如果路径为 `0 -> 1 -> 1 -> 0 -> 1`，那么它表示二进制数 `01101`，也就是 `13` 。

对树上的每一片叶子，我们都要找出从根到该叶子的路径所表示的数字。

返回这些数字之和。题目数据保证答案是一个 **32 位** 整数。

 

**示例 1：**

<img src="https://fzchen-picgo.oss-cn-shanghai.aliyuncs.com/Github/learning/20241223172237866.png" alt="img" style="zoom:50%;" />

```
输入：root = [1,0,1,0,1,0,1]
输出：22
解释：(100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22
```

**示例 2：**

```
输入：root = [0]
输出：0
```

 

**提示：**

- 树中的节点数在 `[1, 1000]` 范围内
- `Node.val` 仅为 `0` 或 `1` 



==**代码**==

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int ans = 0;
    int sumRootToLeaf(TreeNode* root) {
        traverse(root, 0);
        return ans;
    }
    void traverse(TreeNode* root, int sum) {
        if (root == nullptr) {
            return;
        }
        sum = sum * 2 + root->val;
        if (root->left == nullptr && root->right == nullptr) {
            ans += sum;
        }
        traverse(root->left, sum);
        traverse(root->right, sum);
    }
};
```



#### 1457.[二叉树中的伪回文路径](https://leetcode.cn/problems/pseudo-palindromic-paths-in-a-binary-tree/description/)

给你一棵二叉树，每个节点的值为 1 到 9 。我们称二叉树中的一条路径是 「**伪回文**」的，当它满足：路径经过的所有节点值的排列中，存在一个回文序列。

请你返回从根到叶子节点的所有路径中 **伪回文** 路径的数目。

 

**示例 1：**

![img](https://fzchen-picgo.oss-cn-shanghai.aliyuncs.com/Github/learning/20241223175541072.png)

```
输入：root = [2,3,1,3,1,null,1]
输出：2 
解释：上图为给定的二叉树。总共有 3 条从根到叶子的路径：红色路径 [2,3,3] ，绿色路径 [2,1,1] 和路径 [2,3,1] 。
     在这些路径中，只有红色和绿色的路径是伪回文路径，因为红色路径 [2,3,3] 存在回文排列 [3,2,3] ，绿色路径 [2,1,1] 存在回文排列 [1,2,1] 。
```

**示例 2：**

**![img](https://fzchen-picgo.oss-cn-shanghai.aliyuncs.com/Github/learning/20241223175541052.png)**

```
输入：root = [2,1,1,1,3,null,null,null,null,null,1]
输出：1 
解释：上图为给定二叉树。总共有 3 条从根到叶子的路径：绿色路径 [2,1,1] ，路径 [2,1,3,1] 和路径 [2,1] 。
     这些路径中只有绿色路径是伪回文路径，因为 [2,1,1] 存在回文排列 [1,2,1] 。
```

**示例 3：**

```
输入：root = [9]
输出：1
```

 

**提示：**

- 给定二叉树的节点数目在范围 `[1, 105]` 内
- `1 <= Node.val <= 9`



==**代码**==

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int ans = 0;
    unordered_map<int, int> hash_map;
    int pseudoPalindromicPaths (TreeNode* root) {
        traverse(root);
        return ans;
    }
    void traverse(TreeNode* root) {
        if (root == nullptr) {
            return;
        }
        hash_map[root->val]++;
        if (root->left == nullptr && root->right == nullptr) {
            int count = 0;
            for (auto& it : hash_map) {
                if (it.second % 2 == 1) count++;
            }
            if (count <= 1) ans++;
        }
        traverse(root->left);
        traverse(root->right);
        hash_map[root->val]--;
    }
};
```



#### 404.[左叶子之和](https://leetcode.cn/problems/sum-of-left-leaves/description/)

给定二叉树的根节点 `root` ，返回所有左叶子之和。

 

**示例 1：**

<img src="https://fzchen-picgo.oss-cn-shanghai.aliyuncs.com/Github/learning/20241225141556485.jpeg" alt="img" style="zoom:67%;" />

```
输入: root = [3,9,20,null,null,15,7] 
输出: 24 
解释: 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24
```

**示例 2:**

```
输入: root = [1]
输出: 0
```

 

**提示:**

- 节点数在 `[1, 1000]` 范围内
- `-1000 <= Node.val <= 1000`



==**代码**==

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int ans = 0;
    int sumOfLeftLeaves(TreeNode* root) {
        traverse(root);
        return ans;
    }
    void traverse(TreeNode* root) {
        if (root == nullptr) {
            return;
        }
        if (root->left != nullptr && root->left->left == nullptr && root->left->right == nullptr) {
            ans += root->left->val;
        }
        traverse(root->left);
        traverse(root->right);
    }
};
```



#### 971.[翻转二叉树以匹配先序遍历](https://leetcode.cn/problems/flip-binary-tree-to-match-preorder-traversal/description/)

给你一棵二叉树的根节点 `root` ，树中有 `n` 个节点，每个节点都有一个不同于其他节点且处于 `1` 到 `n` 之间的值。

另给你一个由 `n` 个值组成的行程序列 `voyage` ，表示 **预期** 的二叉树 [**先序遍历**](https://baike.baidu.com/item/先序遍历/6442839?fr=aladdin) 结果。

通过交换节点的左右子树，可以 **翻转** 该二叉树中的任意节点。例，翻转节点 1 的效果如下：

![img](https://fzchen-picgo.oss-cn-shanghai.aliyuncs.com/Github/learning/20241226005832266.jpeg)

请翻转 **最少** 的树中节点，使二叉树的 **先序遍历** 与预期的遍历行程 `voyage` **相匹配** 。 

如果可以，则返回 **翻转的** 所有节点的值的列表。你可以按任何顺序返回答案。如果不能，则返回列表 `[-1]`。

 

**示例 1：**

<img src="https://fzchen-picgo.oss-cn-shanghai.aliyuncs.com/Github/learning/20241226005832292.png" alt="img" style="zoom:67%;" />

```
输入：root = [1,2], voyage = [2,1]
输出：[-1]
解释：翻转节点无法令先序遍历匹配预期行程。
```

**示例 2：**

<img src="https://fzchen-picgo.oss-cn-shanghai.aliyuncs.com/Github/learning/20241226005832062.png" alt="img" style="zoom:67%;" />

```
输入：root = [1,2,3], voyage = [1,3,2]
输出：[1]
解释：交换节点 2 和 3 来翻转节点 1 ，先序遍历可以匹配预期行程。
```

**示例 3：**

<img src="https://fzchen-picgo.oss-cn-shanghai.aliyuncs.com/Github/learning/20241226005832062.png" alt="img" style="zoom:67%;" />

```
输入：root = [1,2,3], voyage = [1,2,3]
输出：[]
解释：先序遍历已经匹配预期行程，所以不需要翻转节点。
```

 

**提示：**

- 树中的节点数目为 `n`
- `n == voyage.length`
- `1 <= n <= 100`
- `1 <= Node.val, voyage[i] <= n`
- 树中的所有值 **互不相同**
- `voyage` 中的所有值 **互不相同**



==**代码**==

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> ans;
    vector<int> voyage;
    int index = 0;
    int success = 1;
    vector<int> flipMatchVoyage(TreeNode* root, vector<int>& voyage) {
        this->voyage = voyage;
        traverse(root);
        return success == 1 ? ans : vector<int>{-1};
    }
    void traverse(TreeNode* root) {
        if (root == nullptr) {
            return;
        }
        if (root->val != voyage[index++]) {
            success = 0;
            return;
        }
        if (root->left != nullptr && root->left->val != voyage[index]) {
            TreeNode* tmp = root->left;
            root->left = root->right;
            root->right = tmp;
            ans.push_back(root->val);
        }
        traverse(root->left);
        traverse(root->right);
    }
};
```



#### 987.[二叉树的垂序遍历](https://leetcode.cn/problems/vertical-order-traversal-of-a-binary-tree/description/)

给你二叉树的根结点 `root` ，请你设计算法计算二叉树的 **垂序遍历** 序列。

对位于 `(row, col)` 的每个结点而言，其左右子结点分别位于 `(row + 1, col - 1)` 和 `(row + 1, col + 1)` 。树的根结点位于 `(0, 0)` 。

二叉树的 **垂序遍历** 从最左边的列开始直到最右边的列结束，按列索引每一列上的所有结点，形成一个按出现位置从上到下排序的有序列表。如果同行同列上有多个结点，则按结点的值从小到大进行排序。

返回二叉树的 **垂序遍历** 序列。

 

**示例 1：**

<img src="https://fzchen-picgo.oss-cn-shanghai.aliyuncs.com/Github/learning/20241227002510845.jpeg" alt="img" style="zoom:80%;" />

```
输入：root = [3,9,20,null,null,15,7]
输出：[[9],[3,15],[20],[7]]
解释：
列 -1 ：只有结点 9 在此列中。
列  0 ：只有结点 3 和 15 在此列中，按从上到下顺序。
列  1 ：只有结点 20 在此列中。
列  2 ：只有结点 7 在此列中。
```

**示例 2：**

<img src="https://fzchen-picgo.oss-cn-shanghai.aliyuncs.com/Github/learning/20241227002510861.jpeg" alt="img" style="zoom:80%;" />

```
输入：root = [1,2,3,4,5,6,7]
输出：[[4],[2],[1,5,6],[3],[7]]
解释：
列 -2 ：只有结点 4 在此列中。
列 -1 ：只有结点 2 在此列中。
列  0 ：结点 1 、5 和 6 都在此列中。
          1 在上面，所以它出现在前面。
          5 和 6 位置都是 (2, 0) ，所以按值从小到大排序，5 在 6 的前面。
列  1 ：只有结点 3 在此列中。
列  2 ：只有结点 7 在此列中。
```

**示例 3：**

<img src="https://fzchen-picgo.oss-cn-shanghai.aliyuncs.com/Github/learning/20241227002510619.jpeg" alt="img" style="zoom:80%;" />

```
输入：root = [1,2,3,4,6,5,7]
输出：[[4],[2],[1,5,6],[3],[7]]
解释：
这个示例实际上与示例 2 完全相同，只是结点 5 和 6 在树中的位置发生了交换。
因为 5 和 6 的位置仍然相同，所以答案保持不变，仍然按值从小到大排序。
```

 

**提示：**

- 树中结点数目总数在范围 `[1, 1000]` 内
- `0 <= Node.val <= 1000`



==**代码**==

```c++
class Solution {
public:
    map<int, map<int, vector<int>>> hash_map;
    vector<vector<int>> verticalTraversal(TreeNode* root) {
        traverse(root, 0, 0);
        vector<vector<int>> ans;
        for (auto& [width, depth_map] : hash_map) {
            vector<int> column;
            for (auto& [depth, values] : depth_map) {
                sort(values.begin(), values.end());
                column.insert(column.end(), values.begin(), values.end());
            }
            ans.push_back(column);
        }
        return ans;
    }

private:
    void traverse(TreeNode* root, int width, int depth) {
        if (root == nullptr) {
            return;
        }

        hash_map[width][depth].push_back(root->val);
        traverse(root->left, width - 1, depth + 1);
        traverse(root->right, width + 1, depth + 1);
    }
};
```



#### 993.[二叉树的堂兄弟节点](https://leetcode.cn/problems/cousins-in-binary-tree/description/)

在二叉树中，根节点位于深度 `0` 处，每个深度为 `k` 的节点的子节点位于深度 `k+1` 处。

如果二叉树的两个节点深度相同，但 **父节点不同** ，则它们是一对*堂兄弟节点*。

我们给出了具有唯一值的二叉树的根节点 `root` ，以及树中两个不同节点的值 `x` 和 `y` 。

只有与值 `x` 和 `y` 对应的节点是堂兄弟节点时，才返回 `true` 。否则，返回 `false`。

 

**示例 1：
![img](https://fzchen-picgo.oss-cn-shanghai.aliyuncs.com/Github/learning/20241227004603597.png)**

```
输入：root = [1,2,3,4], x = 4, y = 3
输出：false
```

**示例 2：
![img](https://fzchen-picgo.oss-cn-shanghai.aliyuncs.com/Github/learning/20241227004603116.png)**

```
输入：root = [1,2,3,null,4,null,5], x = 5, y = 4
输出：true
```

**示例 3：**

**![img](https://fzchen-picgo.oss-cn-shanghai.aliyuncs.com/Github/learning/20241227004603360.png)**

```
输入：root = [1,2,3,null,4], x = 2, y = 3
输出：false
```

 

**提示：**

- 二叉树的节点数介于 `2` 到 `100` 之间。
- 每个节点的值都是唯一的、范围为 `1` 到 `100` 的整数。



==**代码**==

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int xdepth = 0, ydepth = 0;
    TreeNode* xparent = nullptr, * yparent = nullptr;
    bool isCousins(TreeNode* root, int x, int y) {
        traverse(root, nullptr, 0, x, y);
        if (xdepth == ydepth && xparent != yparent) {
            return true;
        }
        return false;
    }
    void traverse(TreeNode* root, TreeNode* parent, int depth, int x, int y) {
        if (root == nullptr) {
            return;
        }
        if (root->val == x) {
            xdepth = depth;
            xparent = parent;
        } else if (root->val == y) {
            ydepth = depth;
            yparent = parent;
        }
        traverse(root->left, root, depth + 1, x, y);
        traverse(root->right, root, depth + 1, x, y);
    }
};
```



#### 1315.[祖父节点值为偶数的节点和](https://leetcode.cn/problems/sum-of-nodes-with-even-valued-grandparent/description/)

给你一棵二叉树，请你返回满足以下条件的所有节点的值之和：

- 该节点的祖父节点的值为偶数。（一个节点的祖父节点是指该节点的父节点的父节点。）

如果不存在祖父节点值为偶数的节点，那么返回 `0` 。

 

**示例：**

**<img src="https://fzchen-picgo.oss-cn-shanghai.aliyuncs.com/Github/learning/20241227005733344.png" alt="img" style="zoom:80%;" />**

```
输入：root = [6,7,8,2,7,1,3,9,null,1,4,null,null,null,5]
输出：18
解释：图中红色节点的祖父节点的值为偶数，蓝色节点为这些红色节点的祖父节点。
```

 

**提示：**

- 树中节点的数目在 `1` 到 `10^4` 之间。
- 每个节点的值在 `1` 到 `100` 之间。



==**代码**==

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int ans = 0;
    int sumEvenGrandparent(TreeNode* root) {
        traverse(root, nullptr, nullptr);
        return ans;
    }
    void traverse(TreeNode* root, TreeNode* parent, TreeNode* grandParent) {
        if (root == nullptr) {
            return;
        }
        if (grandParent != nullptr && grandParent->val % 2 == 0) {
            ans += root->val;
        }
        traverse(root->left, root, parent);
        traverse(root->right, root, parent);
    }
};
```



## 广度优先搜索

### 基本模板

```c++
class Solution {
public:
    void levelOrdderTraverse(TreeNode* root) {
        if (root == nullptr) {
            return {};
        }
        
        queue<TreeNode*> q;
        q.push(root);
        //记录当前遍历到的层数(根节点视为第1层)
        int depth = 1;
        while (!q.empty()) {
            // 需要在循环开始前记录队列长度,因为循环过程中队列长度会变化
            int n = q.size();
            for (int i = 0; i < n; i++) {
                TreeNode* cur = q.front();
                q.pop();
                // 将当前节点的左右子树加入到队列中
                if (cur->right != nullptr) {
                    q.push(cur->right);
                }
                if (cur->left != nullptr) {
                    q.push(cur->left);
                }
            }
            depth++;
        }
        return ans;
    }
};
```



### 例题

#### 199.[二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/description/)

给定一个二叉树的 **根节点** `root`，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

 

**示例 1：**

**输入：**root = [1,2,3,null,5,null,4]

**输出：**[1,3,4]

**解释：**

<img src="https://fzchen-picgo.oss-cn-shanghai.aliyuncs.com/Github/learning/20241222202920924.png" alt="img" style="zoom:50%;" />

**示例 2：**

**输入：**root = [1,2,3,4,null,null,null,5]

**输出：**[1,3,4,5]

**解释：**

<img src="https://fzchen-picgo.oss-cn-shanghai.aliyuncs.com/Github/learning/20241222202920903.png" alt="img" style="zoom:50%;" />

**示例 3：**

**输入：**root = [1,null,3]

**输出：**[1,3]

**示例 4：**

**输入：**root = []

**输出：**[]

 

**提示:**

- 二叉树的节点个数的范围是 `[0,100]`
- `-100 <= Node.val <= 100` 



==**代码**==

这里可以反着遍历来提高效率

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        vector<int> ans;
        if (root == nullptr) {
            return {};
        }
        queue<TreeNode*> q;
        q.push(root);
        while (!q.empty()) {
            int n = q.size();
            TreeNode* last = q.front();
            for (int i = 0; i < n; i++) {
                TreeNode* cur = q.front();
                q.pop();
                if (cur->right != nullptr) {
                    q.push(cur->right);
                }
                if (cur->left != nullptr) {
                    q.push(cur->left);
                }
            }
            ans.push_back(last->val);
        }
        return ans;
    }
};
```



## 动态规划

### 例题

#### 623.[在二叉树中增加一行](https://leetcode.cn/problems/add-one-row-to-tree/description/)

给定一个二叉树的根 `root` 和两个整数 `val` 和 `depth` ，在给定的深度 `depth` 处添加一个值为 `val` 的节点行。

注意，根节点 `root` 位于深度 `1` 。

加法规则如下:

- 给定整数 `depth`，对于深度为 `depth - 1` 的每个非空树节点 `cur` ，创建两个值为 `val` 的树节点作为 `cur` 的左子树根和右子树根。
- `cur` 原来的左子树应该是新的左子树根的左子树。
- `cur` 原来的右子树应该是新的右子树根的右子树。
- 如果 `depth == 1 `意味着 `depth - 1` 根本没有深度，那么创建一个树节点，值 `val `作为整个原始树的新根，而原始树就是新根的左子树。

 

**示例 1:**

<img src="https://fzchen-picgo.oss-cn-shanghai.aliyuncs.com/Github/learning/20241225224038994.jpeg" alt="img" style="zoom: 67%;" />

```
输入: root = [4,2,6,3,1,5], val = 1, depth = 2
输出: [4,1,1,2,null,null,6,3,1,5]
```

**示例 2:**

<img src="https://fzchen-picgo.oss-cn-shanghai.aliyuncs.com/Github/learning/20241225224038998.jpeg" alt="img" style="zoom:67%;" />

```
输入: root = [4,2,null,3,1], val = 1, depth = 3
输出:  [4,2,null,1,1,3,null,null,1]
```

 

**提示:**

- 节点数在 `[1, 10^4]` 范围内
- 树的深度在 `[1, 10^4]`范围内
- `-100 <= Node.val <= 100`
- `-10^5 <= val <= 10^5`
- `1 <= depth <= the depth of tree + 1`



==**代码**==

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:

    TreeNode* addOneRow(TreeNode* root, int val, int depth) {
        if (root == nullptr) {
            return nullptr;
        }
        if (depth == 1) {
            TreeNode* newHead = new TreeNode(val, root, nullptr);
            return newHead;
        } else if (depth == 2) {
            root->left = new TreeNode(val, root->left, nullptr);
            root->right = new TreeNode(val, nullptr, root->right);
            return root;
        }
        root->left = addOneRow(root->left, val, depth - 1);
        root->right = addOneRow(root->right, val, depth - 1);
        return root;
    }
};
```



## 构造二叉树

通过前序/中序/后序中的两个遍历结果构造二叉树

![img](https://fzchen-picgo.oss-cn-shanghai.aliyuncs.com/Github/learning/20241219005753341.jpeg)

前序遍历preorder:[3,9,20,15,7]

中序遍历inorder:[9,3,15,20,7]

后序遍历postorder:[9,15,7,20,3]

思路:先确定根节点的值和左右子树的遍历结果,然后递归构造左右子树

假设对于当前子数,前序遍历结果为[preleft,preright],中序为[inleft,inright],后序为[postleft,postright]

### 前序+中序

根节点val和index:

前序:

- 根节点val: preorder[preleft]
- 根节点index: preleft

中序:

- 根节点val: 根据前序获得
- 根节点index: 使用`for循环/哈希表`来查找

左右子树的遍历结果:

中序:

- 左子树: [inleft, 根节点index-1]
- 左子树长度: 根节点index - inleft
- 右子树: [根节点index+1, inright]

前序:

- 左子树: [preleft+1, preleft+左子树长度(根节点index-inleft)]
- 右子树: [preleft+左子树长度+1, preright]

### 后序+中序

根节点val和index:

后序:

- 根节点val: postorder[postright]
- 根节点index: postright

中序:

- 根节点val: 根据后序获得
- 根节点index: 使用`for循环/哈希表`来查找

左右子树的遍历结果

中序:

- 左子树: [inleft,根节点index-1]
- 左子树长度: 根节点index - inleft
- 右子树: [根节点index+1, inright]

后序:

- 左子树: [postleft, postleft+左子树长度-1]
- 右子树: [post+左子树长度, postright-1]

### 前序+后序

根节点val和index:

前序:

- 根节点val: preorder[preleft]
- 根节点index: preleft

后序:

- 根节点val: postorder[postright]
- 根节点index: postright

由于没有中序遍历来区分左右子树,所以可以根据前序遍历的第二个值来找左子树的根节点的值,或者根据后序遍历的倒数第二个值来找右子树的根节点的值.

`需要注意数组越界问题`

左子树根节点val和index:

前序:

- 左子树根节点val: preorder[preleft+1]
- 左子树根节点index: preleft+1

后序:

- 左子树根节点val: 根据前序获得
- 左子树根节点index: 使用`for循环/哈希表`来查找

左右子树的遍历结果

后序: 

- 左子树: [postleft,根节点左子树index]
- 左子树长度: 根节点左子树index - postleft + 1
- 右子树: [根节点左子树index+1, postright-1]

前序:

- 左子树: [preleft+1, preleft+左子树长度]
- 右子树: [preleft+左子树长度+1, preright]

### 例题

#### 654.[最大二叉树](https://leetcode.cn/problems/maximum-binary-tree/description/)

给定一个不重复的整数数组 `nums` 。 **最大二叉树** 可以用下面的算法从 `nums` 递归地构建:

1. 创建一个根节点，其值为 `nums` 中的最大值。
2. 递归地在最大值 **左边** 的 **子数组前缀上** 构建左子树。
3. 递归地在最大值 **右边** 的 **子数组后缀上** 构建右子树。

返回 *`nums` 构建的* ***最大二叉树\*** 。

 

**示例 1：**

<img src="https://fzchen-picgo.oss-cn-shanghai.aliyuncs.com/Github/learning/20241218224506200.jpeg" alt="img" style="zoom:67%;" />

```
输入：nums = [3,2,1,6,0,5]
输出：[6,3,5,null,2,0,null,null,1]
解释：递归调用如下所示：
- [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。
    - [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。
        - 空数组，无子节点。
        - [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。
            - 空数组，无子节点。
            - 只有一个元素，所以子节点是一个值为 1 的节点。
    - [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。
        - 只有一个元素，所以子节点是一个值为 0 的节点。
        - 空数组，无子节点。
```

**示例 2：**

<img src="https://fzchen-picgo.oss-cn-shanghai.aliyuncs.com/Github/learning/20241218224506108.jpeg" alt="img" style="zoom:67%;" />

```
输入：nums = [3,2,1]
输出：[3,null,2,null,1]
```

 

**提示：**

- `1 <= nums.length <= 1000`
- `0 <= nums[i] <= 1000`
- `nums` 中的所有整数 **互不相同**



==**代码**==

自底向上DFS

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        int n = nums.size();
        return construct(nums, 0, n - 1);
    }
    TreeNode* construct(vector<int>& nums, int left, int right) {
        if (left > right) return nullptr;

        int index = left;
        for (int i = left; i <= right; i++) {
            if (nums[i] > nums[index]) {
                index = i;
            }
        }

        TreeNode* newNode = new TreeNode(nums[index]);
        newNode->left = construct(nums, left, index - 1);
        newNode->right = construct(nums, index + 1, right);
        return newNode;
    }
};
```



#### 105.[从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/)

给定两个整数数组 `preorder` 和 `inorder` ，其中 `preorder` 是二叉树的**先序遍历**， `inorder` 是同一棵树的**中序遍历**，请构造二叉树并返回其根节点。

 

**示例 1:**

![img](https://fzchen-picgo.oss-cn-shanghai.aliyuncs.com/Github/learning/20241219005330036.jpeg)

```
输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
输出: [3,9,20,null,null,15,7]
```

**示例 2:**

```
输入: preorder = [-1], inorder = [-1]
输出: [-1]
```

 

**提示:**

- `1 <= preorder.length <= 3000`
- `inorder.length == preorder.length`
- `-3000 <= preorder[i], inorder[i] <= 3000`
- `preorder` 和 `inorder` 均 **无重复** 元素
- `inorder` 均出现在 `preorder`
- `preorder` **保证** 为二叉树的前序遍历序列
- `inorder` **保证** 为二叉树的中序遍历序列



==**代码**==

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    unordered_map<int, int> hash_map;
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        int n = preorder.size();
        for (int i = 0; i < n; i++) {
            hash_map[inorder[i]] = i;
        }
        return build(preorder, 0, n - 1, inorder, 0, n - 1);
    }
    TreeNode* build(vector<int>& preorder, int preleft, int preright, vector<int>& inorder, int inleft, int inright) {
        if (preleft > preright) return nullptr;
        int value = preorder[preleft];
        int index = hash_map[value];
        int leftSize = index - inleft;
        TreeNode* root = new TreeNode(value);
        root->left = build(preorder, preleft + 1, preleft + leftSize, inorder, inleft, index - 1);
        root->right = build(preorder, preleft + leftSize + 1, preright, inorder, index + 1, inright);
        return root;
    }
};
```



#### 106.[从中序与后序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/)

给定两个整数数组 `inorder` 和 `postorder` ，其中 `inorder` 是二叉树的中序遍历， `postorder` 是同一棵树的后序遍历，请你构造并返回这颗 *二叉树* 。

 

**示例 1:**

![img](https://fzchen-picgo.oss-cn-shanghai.aliyuncs.com/Github/learning/20241219231546717.jpeg)

```
输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]
输出：[3,9,20,null,null,15,7]
```

**示例 2:**

```
输入：inorder = [-1], postorder = [-1]
输出：[-1]
```

 

**提示:**

- `1 <= inorder.length <= 3000`
- `postorder.length == inorder.length`
- `-3000 <= inorder[i], postorder[i] <= 3000`
- `inorder` 和 `postorder` 都由 **不同** 的值组成
- `postorder` 中每一个值都在 `inorder` 中
- `inorder` **保证**是树的中序遍历
- `postorder` **保证**是树的后序遍历



==**代码**==

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    unordered_map<int, int> hash_map;
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        int n = inorder.size();
        for (int i = 0; i < n; i++) {
            hash_map[inorder[i]] = i;
        }
        return build(inorder, 0, n - 1, postorder, 0, n - 1);
    }
    TreeNode* build(vector<int>& inorder, int inleft, int inright, vector<int>& postorder, int postleft, int postright) {
        if (postleft > postright) return nullptr;
        int value = postorder[postright];
        int index = hash_map[value];
        int leftSize = index - inleft;
        TreeNode* root = new TreeNode(value);
        root->left = build(inorder, inleft, index - 1, postorder, postleft, postleft + leftSize - 1);
        root->right = build(inorder, index + 1, inright, postorder, postleft + leftSize, postright - 1);
        return root;
    }
};
```



#### 889.[根据前序和后序遍历构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/description/)

给定两个整数数组，`preorder` 和 `postorder` ，其中 `preorder` 是一个具有 **无重复** 值的二叉树的前序遍历，`postorder` 是同一棵树的后序遍历，重构并返回二叉树。

如果存在多个答案，您可以返回其中 **任何** 一个。

 

**示例 1：**

![img](https://fzchen-picgo.oss-cn-shanghai.aliyuncs.com/Github/learning/20241219234914116.jpeg)

```
输入：preorder = [1,2,4,5,3,6,7], postorder = [4,5,2,6,7,3,1]
输出：[1,2,3,4,5,6,7]
```

**示例 2:**

```
输入: preorder = [1], postorder = [1]
输出: [1]
```

 

**提示：**

- `1 <= preorder.length <= 30`
- `1 <= preorder[i] <= preorder.length`
- `preorder` 中所有值都 **不同**
- `postorder.length == preorder.length`
- `1 <= postorder[i] <= postorder.length`
- `postorder` 中所有值都 **不同**
- 保证 `preorder` 和 `postorder` 是同一棵二叉树的前序遍历和后序遍历



==**代码**==

注意寻找左子树根节点val时需要考虑数组越界问题

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    unordered_map<int, int> hash_map;
    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {
        int n = preorder.size();
        for (int i = 0; i < n; i++) {
            hash_map[postorder[i]] = i;
        }
        return build(preorder, 0, n - 1, postorder, 0, n - 1);
    }
    TreeNode* build(vector<int>& preorder, int preleft, int preright, vector<int>& postorder, int postleft, int postright) {
        if (preleft > preright) return nullptr;
        int value = preorder[preleft];
        TreeNode* root = new TreeNode(value);
        if (preleft == preright) {
            return root;
        }
        int rootLeftVal = preorder[preleft + 1];
        int index = hash_map[rootLeftVal];
        int leftSize = index - postleft + 1;
        root->left = build(preorder, preleft + 1, preleft + leftSize, postorder, postleft, index);
        root->right = build(preorder, preleft + leftSize + 1, preright, postorder, index + 1, postright - 1);
        return root;
    }
};
```



## 二叉树序列化

当二叉树节点的值不重复时:

1. 如果序列化结果不包含空指针信息,且有1种遍历结果,那么二叉树不唯一
2. 如果序列化结果不包含空指针信息,且有2种遍历结果,那么
   - 前序/后序 + 中序,二叉树唯一
   - 前序 + 后序,二叉树不唯一
3. 如果序列化结果包含空指针信息,且有1种遍历结果,那么
   - 前序/后序,二叉树唯一
   - 中序,二叉树不唯一

序列化和反序列化

- 序列化:正常遍历
- 反序列化:
  - 先确认根节点root
  - 根据前序/中序/后序遍历规则,递归生成左右子树

### 前序遍历

使用`","`作为分隔符,使用`"#"`表示叶子节点

```c++
class Codec {
public:
    string SEP = ","; // 代表分隔不同节点的字符
    string NULLSYM = "#"; // 代表叶子节点的字符

    // 将二叉树序列化为字符串
    string serialize(TreeNode* root) {
        string str;
        _serialize(root, str);
        return str;
    }

    void _serialize(TreeNode* root, string& str) {
        if (root == NULL) {
            str.append(NULLSYM).append(SEP);
            return;
        }

        str.append(to_string(root->val)).append(SEP);
        _serialize(root->left, str);
        _serialize(root->right, str);
    }
    
    // 将字符串反序列化为二叉树
    TreeNode* deserialize(string data) {
        // 将字符串转化成列表
        list<string> nodes;
        istringstream f(data);
        string s;    
        while (getline(f, s, ',')) {
            nodes.push_back(s);
        }
        return _deserialize(nodes);
    }

    TreeNode* _deserialize(list<string>& nodes) {
        if (nodes.empty()) return nullptr;
		
        // 找到nodes第一个字符作为根节点
        string first = nodes.front();
        nodes.pop_front();
        if (first == NULLSYM) return nullptr;
        TreeNode* root = new TreeNode(stoi(first));

        root->left = _deserialize(nodes);
        root->right = _deserialize(nodes);

        return root;
    }
};
```



### 后序遍历

只有`_serialize`和` _deserialize`函数需要修改

```c++
class Codec {
public:
    string SEP = ",";
    string NULL_STR = "#";

    // 主函数，将二叉树序列化为字符串
    string serialize(TreeNode* root) {
        string str;
        _serialize(root, str);
        return str;
    }

    void _serialize(TreeNode* root, string& str) {
        if (root == nullptr) {
            str += NULL_STR + SEP;
            return;
        }
        
        _serialize(root->left, str);
        _serialize(root->right, str);
        str += to_string(root->val) + SEP;
    }

    // 主函数，将字符串反序列化为二叉树结构
    TreeNode* deserialize(string data) {
        list<string> nodes;
        stringstream ss(data);
        string buf;
        while (getline(ss, buf, ',')) {
            nodes.push_back(buf);
        }
        return _deserialize(nodes);
    }

    // 辅助函数，通过 nodes 列表构造二叉树
    TreeNode* _deserialize(list<string>& nodes) {
        if (nodes.empty()) return nullptr;
        // 从后往前取出元素
        string last = nodes.back();
        nodes.pop_back();
        if (last == NULL_STR) return nullptr;
        TreeNode* root = new TreeNode(stoi(last));
        // 先构造右子树，后构造左子树
        root->right = _deserialize(nodes);
        root->left = _deserialize(nodes);
        
        return root;
    }
};
```



### 中序遍历

可以序列化,但是不能反序列化,因为无法确定根节点的位置

```c++
class Codec {
public:
    string SEP = ",";
    string NULL_STR = "#";

    // 主函数，将二叉树序列化为字符串
    string serialize(TreeNode* root) {
        string str;
        _serialize(root, str);
        return str;
    }

    void _serialize(TreeNode* root, string& str) {
        if (root == nullptr) {
            str += NULL_STR + SEP;
            return;
        }
        
        _serialize(root->left, str);
        str += to_string(root->val) + SEP;
        _serialize(root->right, str);
    }
};
```



### 层序遍历

```c++
class Codec {
    string SEP = ",";
    string NULLSYM = "#";
  
public:
    // 将二叉树序列化为字符串
    string serialize(TreeNode* root) {
        if (root == nullptr) return "";
        string str;
        // 初始化队列，将 root 加入队列
        queue<TreeNode*> q;
        q.push(root);
        
        while (!q.empty()) {
            int sz = q.size();
            for (int i = 0; i < sz; ++i) {
                TreeNode* cur = q.front();
                q.pop();
                // 层级遍历代码位置
                if (cur == nullptr) {
                    str += NULL + SEP;
                    continue;
                }
                str += to_string(cur->val) + SEP;
                // ***************
                q.push(cur->left);
                q.push(cur->right);
            }
        }
        return sb;
    }
    
    // 将字符串反序列化为二叉树结构
    TreeNode* deserialize(string data) {
        if (data.empty()) return nullptr;
        stringstream ss(data);
        string item;
        getline(ss, item, ',');
        // 第一个元素就是 root 的值
        TreeNode* root = new TreeNode(stoi(item));
        // 队列 q 记录父节点，将 root 加入队列
        queue<TreeNode*> q;
        q.push(root);

        while (!q.empty()) {
            int sz = q.size();
            for (int i = 0; i < sz; i++) {
                TreeNode* parent = q.front();
                q.pop();
                // 为父节点构造左侧子节点
                if(!getline(ss, item, ',') || item == NULLSYM) {  
                    parent->left = nullptr;  
                } else {
                    parent->left = new TreeNode(stoi(item));
                    q.push(parent->left);
                }
                // 为父节点构造右侧子节点
                if(!getline(ss, item, ',') || item == NULLSYM) {  
                    parent->right = nullptr;  
                } else {
                    parent->right = new TreeNode(stoi(item));
                    q.push(parent->right);
                }
            }
        }
        return root;
    }
};
```



## 其他

### 例题

#### 652.[寻找重复的子树](https://leetcode.cn/problems/find-duplicate-subtrees/description/)

给你一棵二叉树的根节点 `root` ，返回所有 **重复的子树** 。

对于同一类的重复子树，你只需要返回其中任意 **一棵** 的根结点即可。

如果两棵树具有 **相同的结构** 和 **相同的结点值** ，则认为二者是 **重复** 的。

 

**示例 1：**

![img](https://fzchen-picgo.oss-cn-shanghai.aliyuncs.com/Github/learning/20241221000515900.jpeg)

```
输入：root = [1,2,3,4,null,2,4,null,null,4]
输出：[[2,4],[4]]
```

**示例 2：**

![img](https://fzchen-picgo.oss-cn-shanghai.aliyuncs.com/Github/learning/20241221000515659.jpeg)

```
输入：root = [2,1,1]
输出：[[1]]
```

**示例 3：**

**![img](https://fzchen-picgo.oss-cn-shanghai.aliyuncs.com/Github/learning/20241221000515885.jpeg)**

```
输入：root = [2,2,2,3,null,3,null]
输出：[[2,3],[3]]
```

 

**提示：**

- 树中的结点数在 `[1, 5000]` 范围内。
- `-200 <= Node.val <= 200`



==**代码**==

- 是否可以通过一次遍历二叉树来完成?
  - 可以!

- 首先考虑对于某一个节点,需要知道什么信息
  - 1.以我为根节点的子树的序列
  - 2.以其他节点为根节点的子树的序列
- 第1点可以在后序位置知道左右子树情况,可以通过拼接字符串的方式把二叉树序列化
- 第2点可以通过哈希表来知道
  - 注意某种情况有3个以上重复子树时只需要加入一次,所以需要判断`hash_map[str] == 1`

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    unordered_map<string, int> hash_map;
    vector<TreeNode*> ans;
    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {
        traverse(root);
        return ans;
    }
    string traverse(TreeNode* root) {
        if (root == nullptr) {
            return "#";
        }
        string left = traverse(root->left);
        string right = traverse(root->right);
        string str = left + "," + right + "," + to_string(root->val);
        if (hash_map[str] == 1) {
            ans.push_back(root);
        }
        hash_map[str]++;
        return str;
    }
};
```

