# 指针
用途:间接访问内存,记录的是变量在内存中的地址
## 指针的使用
###### 声明

```c++
数据类型 *p;//例如int *p
```
###### 赋值

```c++
p = &a;//例如此时a=10,p=0x1111
```
###### 解引用

通过指针修改变量的值

```c++
*p = 1000;
```
## 指针所占内存空间
所有类型的指针在32位操作系统中占4个字节,在64位系统中占8个字节(即操作系统位数)

因为32位系统地址总线为32位,所以地址编号也是32位

## 空指针和野指针
空指针和野指针都是我们申请的空间,所以不要且无法访问
#### 空指针
指针指向内存中编号为0的空间
```c++
int *p = NULL;
```
用途:初始化指针变量(暂时不知道如何分配的指针)

注意空指针指向的内存无法访问

#### 野指针
野指针指向的是非法的内存空间,未分配的/没有权限的空间
```c++
int *p = (int *)0x1111;
```
编译器无法发现这个问题,因为语法没有问题.但是运行时会报错,因为指针p并没有对该内存空间的读取权限
## const修饰指针
const修饰指针有三种情况:

1.const修饰指针:常量指针

指针的指向可以修改,指针指向的值不能修改

```c++
int a = 10;
int b = 20;
const int *p = &a;
*p = 20;//错误,指针指向的值不可以改
p = &b;//正确,指针指向可以改
```

2.const修饰常量:指针常量

指针的指向不可以改,指针指向的值可以改

```c++
int a = 10;
int b = 20;
int *const p = &a;
*p = 20;//正确,指针指向的值可以改
p = &b;//错误,指针指向不可以改
```

3.const既修饰指针又修饰常量

指针的指向和指针指向的值都不可以改

```c++
int a = 10;
int b = 20;
const int *const p = &a;
*p = 20;//错误,指针指向的值不可以改
p = &b;//错误,指针指向不可以改
```

## 指针访问数组

```c++
int arr[5] = {1, 2, 3, 4, 5,};
int *p = arr;//此时*p = 1
p++;//此时*p = 2
```

## 指针访问函数

注意值传递和地址传递的区别

```c++
void swap1(int a, int b) {
    int temp = a;
    a = b;
    b = temp;
}

void swap2(int *a, int *b) {
    int temp = *a;
    *a = *b;
    *b = *temp;
}

int main() {
    int a = 10;
    int b = 20;
    swap1(a, b);//交换失败,a=10,b=20
    swap2(&a, &b);//交换成功,a=20,b=10
    return 0;
}
```

